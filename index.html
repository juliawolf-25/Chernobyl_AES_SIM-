<!DOCTYPE html>
<html>
<head>
    <title>–ß–µ—Ä–Ω–æ–±—ã–ª—å—Å–∫–∞—è –ê–≠–° - –¢–æ—á–Ω–∞—è –º–æ–¥–µ–ª—å –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ—ã 26 –∞–ø—Ä–µ–ª—è</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        canvas { 
            display: block; 
            cursor: grab;
            width: 100%;
            height: 100%;
        }
        canvas:active {
            cursor: grabbing;
        }
        .info-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #ff4444;
            max-width: 350px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        .status-indicator {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .normal { background: #4CAF50; }
        .warning { background: #ff9800; }
        .critical { background: #f44336; }
        .catastrophe { background: #d32f2f; }
        
        .timer {
            font-size: 18px;
            color: #ff9800;
            margin: 10px 0;
            text-align: center;
        }
        
        .compact-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .compact-controls button {
            padding: 8px 12px;
            font-size: 12px;
            margin: 0;
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .compact-controls button.active {
            background: linear-gradient(45deg, #FF9800, #FFC107);
        }
        
        .reactor-controls {
            position: absolute;
            bottom: 25px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .reactor-controls button {
            background: linear-gradient(45deg, #ff4444, #ff6b6b);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3);
        }
        
        .reactor-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }
        
        .reactor-controls button:last-child {
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
        }
        
        .camera-hint {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        
        .reactor-panel {
            position: absolute;
            bottom: 25px;
            left: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            width: 250px;
            z-index: 100;
            border: 2px solid #ff4444;
        }
        
        .reactor-panel h3 {
            margin: 0 0 12px 0;
            text-align: center;
            color: #ff9800;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            font-size: 14px;
        }
        
        .reactor-parameter {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .reactor-parameter label {
            font-weight: bold;
            color: #ff9800;
        }
        
        .reactor-value {
            font-family: 'Courier New', monospace;
            background: #222;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 60px;
            text-align: center;
            font-size: 11px;
        }
        
        .reactor-slider {
            width: 100%;
            margin: 3px 0;
            height: 6px;
        }
        
        .az5-button {
            background: linear-gradient(45deg, #ff4444, #ff6b6b);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            margin-top: 8px;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .az5-button:hover {
            background: linear-gradient(45deg, #ff2222, #ff5555);
            transform: translateY(-2px);
        }
        
        .parameter-warning {
            color: #ff9800;
            font-size: 10px;
            text-align: center;
            margin-top: 3px;
        }
        
        .parameter-critical {
            color: #ff4444;
            font-size: 10px;
            text-align: center;
            margin-top: 3px;
            font-weight: bold;
        }
        
        .sound-controls {
            position: absolute;
            bottom: 15px;
            right: 200px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .sound-controls button {
            background: linear-gradient(45deg, #9C27B0, #E91E63);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
        }
        
        /* –ú–æ–±–∏–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ */
        @media (max-width: 768px) {
            .info-panel {
                max-width: 280px;
                padding: 15px;
                font-size: 14px;
            }
            
            .compact-controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: calc(100% - 30px);
                right: 15px;
                top: auto;
                bottom: 150px;
            }
            
            .compact-controls button {
                flex: 1;
                min-width: 80px;
                font-size: 10px;
                padding: 6px 8px;
            }
            
            .reactor-panel {
                width: calc(100% - 30px);
                bottom: 300px;
                left: 15px;
            }
            
            .reactor-controls {
                bottom: 15px;
                right: 15px;
                width: calc(100% - 30px);
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .reactor-controls button {
                flex: 1;
                min-width: 100px;
                font-size: 11px;
                padding: 8px 10px;
            }
            
            .sound-controls {
                bottom: 80px;
                right: 15px;
                width: calc(100% - 30px);
                justify-content: center;
            }
            
            .camera-hint {
                display: none;
            }
            
            .timer {
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .info-panel {
                max-width: 220px;
                padding: 10px;
                font-size: 12px;
            }
            
            .compact-controls button {
                font-size: 9px;
                padding: 5px 6px;
            }
            
            .reactor-panel {
                bottom: 320px;
            }
            
            .reactor-controls button {
                font-size: 10px;
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="info-panel">
        <h2>‚ö° –ß–µ—Ä–Ω–æ–±—ã–ª—å—Å–∫–∞—è –ê–≠–° - 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫</h2>
        <div class="timestamp">26 –∞–ø—Ä–µ–ª—è 1986, 01:23:45</div>
        
        <div class="status-indicator normal" id="statusIndicator">
            <span id="statusText">–ù–û–†–ú–ê–õ–¨–ù–ê–Ø –†–ê–ë–û–¢–ê</span>
        </div>
        
        <div class="timer" id="timer">
            –í—Ä–µ–º—è –ø–æ—Å–ª–µ –≤–∑—Ä—ã–≤–∞: <span id="timeValue">0.0</span>—Å
        </div>
        
        <div id="phaseDescription">–†–µ–∞–∫—Ç–æ—Ä –†–ë–ú–ö-1000 —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —à—Ç–∞—Ç–Ω–æ–º —Ä–µ–∂–∏–º–µ.</div>
    </div>

    <div class="compact-controls">
        <button class="active" onclick="switchToStation()">üè≠ –°—Ç–∞–Ω—Ü–∏—è</button>
        <button onclick="switchToCity()">üèôÔ∏è –ì–æ—Ä–æ–¥</button>
        <button onclick="switchToSettlement()">üèòÔ∏è –ü–æ—Å–µ–ª–µ–Ω–∏–µ</button>
        <button onclick="switchToBridge()">üåâ –ú–æ—Å—Ç</button>
        <button onclick="toggleDayNight()">üåì –î–µ–Ω—å/–ù–æ—á—å</button>
    </div>

    <div class="reactor-controls">
        <button onclick="startExplosionSequence()">üí• –ó–ê–ü–£–°–ö –í–ó–†–´–í–ê</button>
        <button onclick="spawnEmergencyVehicles()">üöí –í–´–ó–í–ê–¢–¨ –¢–ï–•–ù–ò–ö–£</button>
        <button onclick="startRebuildSequence()">üèóÔ∏è –í–û–°–°–¢–ê–ù–û–í–ò–¢–¨</button>
    </div>

    <div class="sound-controls">
        <button onclick="toggleAmbientSound()">üîä –§–æ–Ω</button>
        <button onclick="playExplosionSound()">üí• –í–∑—Ä—ã–≤</button>
        <button onclick="playSirenSound()">üö® –°–∏—Ä–µ–Ω–∞</button>
    </div>

    <div class="reactor-panel">
        <h3>–ü–£–õ–¨–¢ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –†–ï–ê–ö–¢–û–†–û–ú</h3>
        
        <div class="reactor-parameter">
            <label>–ú–æ—â–Ω–æ—Å—Ç—å (–ú–í—Ç):</label>
            <div class="reactor-value" id="powerValue">700</div>
        </div>
        <input type="range" min="0" max="1000" value="700" class="reactor-slider" id="powerSlider" oninput="updatePower(this.value)">
        
        <div class="reactor-parameter">
            <label>–°—Ç–µ—Ä–∂–Ω–∏ (—à—Ç):</label>
            <div class="reactor-value" id="rodsValue">187</div>
        </div>
        <input type="range" min="0" max="211" value="187" class="reactor-slider" id="rodsSlider" oninput="updateRods(this.value)">
        
        <div class="reactor-parameter">
            <label>–†–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (Œ≤):</label>
            <div class="reactor-value" id="reactivityValue">0.5</div>
        </div>
        <div id="reactivityWarning" class="parameter-warning">–ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</div>
        
        <button class="az5-button" onclick="activateAZ5()">‚õî –ê–ó-5 (–ê–í–ê–†–ò–ô–ù–ê–Ø –ó–ê–©–ò–¢–ê)</button>
        <div id="az5Warning" class="parameter-warning">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ä–µ–∞–∫—Ç–æ—Ä–∞</div>
    </div>

    <div class="camera-hint">
        –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π: –õ–ö–ú + –¥–≤–∏–∂–µ–Ω–∏–µ - –≤—Ä–∞—â–µ–Ω–∏–µ, –ö–æ–ª–µ—Å–æ –º—ã—à–∏ - –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
    </div>

    <!-- –ê—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
    <audio id="ambientSound" loop>
        <source src="https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3" type="audio/mp3">
    </audio>
    <audio id="explosionSound">
        <source src="https://assets.mixkit.co/active_storage/sfx/245/245-preview.mp3" type="audio/mp3">
    </audio>
    <audio id="sirenSound" loop>
        <source src="https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3" type="audio/mp3">
    </audio>
    <audio id="nuclearAlarm">
        <source src="https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3" type="audio/mp3">
    </audio>
    <audio id="vehicleSound" loop>
        <source src="https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3" type="audio/mp3">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // –ó–≤—É–∫–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let isAmbientSoundPlaying = false;

        function toggleAmbientSound() {
            const ambientSound = document.getElementById('ambientSound');
            if (isAmbientSoundPlaying) {
                ambientSound.pause();
                isAmbientSoundPlaying = false;
            } else {
                ambientSound.play().catch(e => console.log('Audio play failed:', e));
                isAmbientSoundPlaying = true;
            }
        }

        function playExplosionSound() {
            const explosionSound = document.getElementById('explosionSound');
            explosionSound.currentTime = 0;
            explosionSound.play().catch(e => console.log('Audio play failed:', e));
        }

        function playSirenSound() {
            const sirenSound = document.getElementById('sirenSound');
            if (sirenSound.paused) {
                sirenSound.play().catch(e => console.log('Audio play failed:', e));
            } else {
                sirenSound.pause();
                sirenSound.currentTime = 0;
            }
        }

        function playNuclearAlarm() {
            const nuclearAlarm = document.getElementById('nuclearAlarm');
            nuclearAlarm.currentTime = 0;
            nuclearAlarm.play().catch(e => console.log('Audio play failed:', e));
        }

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        let sunLight, ambientLight;
        let isDayMode = true;
        let currentLocation = 'station';

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        let settlementPeople = [];
        let stationPeople = [];
        let cityPeople = [];
        let cityVehicles = [];
        let emergencyVehicles = [];
        let machineHallEquipment = [];
        let streetLights = [];
        let buildingLights = [];
        let explosionEffects = [];
        let smokeParticles = [];
        let fireEffects = [];
        let radioactiveCloud = null;
        let steamParticles = [];
        let tecSmokeParticles = [];
        let reactorRods = [];
        let unit4Destroyed = false;
        let stationLightsOn = true;
        let evacuationStarted = false;
        let debrisParticles = [];
        let destroyedUnit4 = null;
        let coolingTowerSteam = [];
        let blackSmokeParticles = [];

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∞–∫—Ç–æ—Ä–∞ –¥–ª—è –ø–∞—Ä–∞
        const reactorBounds = {
            minX: -4,
            maxX: 4,
            minY: 2,
            maxY: 8,
            minZ: -4,
            maxZ: 4
        };

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∞–∫—Ç–æ—Ä–æ–º
        const reactorState = {
            power: 700,
            controlRods: 187,
            reactivity: 0.5,
            az5Activated: false,
            explosionTriggered: false
        };

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        const controls = {
            explosionStarted: false,
            explosionTime: 0,
            autoRotate: false,
            lightsOn: true,
            earthquakeActive: false,
            processesStopped: false
        };

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–µ–º–ª–∏ —Å —Ä–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π
        function createGround() {
            const groundGroup = new THREE.Group();
            
            const mainGround = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.MeshPhongMaterial({ color: 0xd2b48c })
            );
            mainGround.rotation.x = -Math.PI / 2;
            mainGround.position.y = -0.1;
            groundGroup.add(mainGround);
            
            const stationGround = new THREE.Mesh(
                new THREE.PlaneGeometry(400, 400),
                new THREE.MeshPhongMaterial({ color: 0x888888 })
            );
            stationGround.rotation.x = -Math.PI / 2;
            stationGround.position.set(0, 0, 0);
            groundGroup.add(stationGround);
            
            const cityGround = new THREE.Mesh(
                new THREE.PlaneGeometry(800, 800),
                new THREE.MeshPhongMaterial({ color: 0x44aa44 })
            );
            cityGround.rotation.x = -Math.PI / 2;
            cityGround.position.set(200, 0, -300);
            groundGroup.add(cityGround);
            
            const settlementGround = new THREE.Mesh(
                new THREE.PlaneGeometry(400, 400),
                new THREE.MeshPhongMaterial({ color: 0x44aa44 })
            );
            settlementGround.rotation.x = -Math.PI / 2;
            settlementGround.position.set(600, 0, -300);
            groundGroup.add(settlementGround);

            // –°–æ–∑–¥–∞–µ–º —Å–ª–æ–∂–Ω—É—é —Ä–µ—á–Ω—É—é —Å–∏—Å—Ç–µ–º—É
            createRiverSystem(groundGroup);

            // –í–æ–¥–æ—ë–º –≤–æ–∑–ª–µ —Å—Ç–∞–Ω—Ü–∏–∏ (—Å–æ–µ–¥–∏–Ω–µ–Ω —Å —Ä–µ–∫–æ–π)
            const stationPond = createPond(120, 80);
            stationPond.position.set(150, 0.1, 100);
            groundGroup.add(stationPond);

            // –ö–∞–Ω–∞–ª —Å–æ–µ–¥–∏–Ω—è—é—â–∏–π –≤–æ–¥–æ—ë–º —Å —Ä–µ–∫–æ–π
            const canal1 = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 8),
                new THREE.MeshPhongMaterial({ color: 0x0066cc, transparent: true, opacity: 0.8 })
            );
            canal1.rotation.x = -Math.PI / 2;
            canal1.position.set(190, 0.1, 140);
            groundGroup.add(canal1);

            // –î–æ—Ä–æ–≥–∏ –æ—Ç –≥–æ—Ä–æ–¥–∞ –∫ —Å—Ç–∞–Ω—Ü–∏–∏ –∏ –∫ –ø–æ—Å–µ–ª–µ–Ω–∏—é
            createRoadsToStation(groundGroup);

            return groundGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ—Ä–æ–≥ –æ—Ç –≥–æ—Ä–æ–¥–∞ –∫ —Å—Ç–∞–Ω—Ü–∏–∏ –∏ –∫ –ø–æ—Å–µ–ª–µ–Ω–∏—é
        function createRoadsToStation(groundGroup) {
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            // –ì–ª–∞–≤–Ω–∞—è –¥–æ—Ä–æ–≥–∞ –æ—Ç –≥–æ—Ä–æ–¥–∞ –∫ —Å—Ç–∞–Ω—Ü–∏–∏
            const mainRoad = new THREE.Mesh(
                new THREE.BoxGeometry(400, 0.2, 12),
                roadMaterial
            );
            mainRoad.position.set(100, 0.1, -190);
            mainRoad.rotation.y = Math.PI / 2;
            groundGroup.add(mainRoad);
            
            // –ü–æ–¥—ä–µ–∑–¥–Ω—ã–µ –¥–æ—Ä–æ–≥–∏ –∫ —Å—Ç–∞–Ω—Ü–∏–∏
            const stationRoad1 = new THREE.Mesh(
                new THREE.BoxGeometry(200, 0.2, 8),
                roadMaterial
            );
            stationRoad1.position.set(-50, 0.1, -80);
            groundGroup.add(stationRoad1);
            
            const stationRoad2 = new THREE.Mesh(
                new THREE.BoxGeometry(150, 0.2, 8),
                roadMaterial
            );
            stationRoad2.position.set(50, 0.1, -50);
            stationRoad2.rotation.y = Math.PI / 4;
            groundGroup.add(stationRoad2);
            
            // –î–æ—Ä–æ–≥–∞ –æ—Ç —Å—Ç–∞–Ω—Ü–∏–∏ –∫ –ø–æ—Å–µ–ª–µ–Ω–∏—é —á–µ—Ä–µ–∑ –º–æ—Å—Ç
            const roadToSettlement = new THREE.Mesh(
                new THREE.BoxGeometry(600, 0.2, 8),
                roadMaterial
            );
            roadToSettlement.position.set(200, 0.1, -100);
            roadToSettlement.rotation.y = Math.PI / 2;
            groundGroup.add(roadToSettlement);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
        function createRiverSystem(groundGroup) {
            // –ì–ª–∞–≤–Ω–∞—è –±–æ–ª—å—à–∞—è —Ä–µ–∫–∞
            const mainRiver = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 2500),
                new THREE.MeshPhongMaterial({ color: 0x0066cc, transparent: true, opacity: 0.8 })
            );
            mainRiver.rotation.x = -Math.PI / 2;
            mainRiver.position.set(500, 0.1, 0);
            groundGroup.add(mainRiver);

            // –ü—Ä–∏—Ç–æ–∫ –∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–∫–µ
            const tributary = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 600),
                new THREE.MeshPhongMaterial({ color: 0x0066cc, transparent: true, opacity: 0.8 })
            );
            tributary.rotation.x = -Math.PI / 2;
            tributary.rotation.z = Math.PI / 4;
            tributary.position.set(300, 0.1, -400);
            groundGroup.add(tributary);

            // –ë–µ—Ä–µ–≥–∞ —Ä–µ–∫
            const riverBanks = [
                { position: [477.5, 0.05, 0], size: [5, 2500] },
                { position: [522.5, 0.05, 0], size: [5, 2500] },
                { position: [287.5, 0.05, -400], size: [3, 600], rotation: Math.PI/4 },
                { position: [312.5, 0.05, -400], size: [3, 600], rotation: Math.PI/4 }
            ];

            riverBanks.forEach(bank => {
                const bankMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(bank.size[0], bank.size[1]),
                    new THREE.MeshPhongMaterial({ color: 0xc2b280 })
                );
                bankMesh.rotation.x = -Math.PI / 2;
                if (bank.rotation) bankMesh.rotation.z = bank.rotation;
                bankMesh.position.set(bank.position[0], bank.position[1], bank.position[2]);
                groundGroup.add(bankMesh);
            });
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–æ–¥–æ—ë–º–∞
        function createPond(width, height) {
            const pondGroup = new THREE.Group();
            
            const pond = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshPhongMaterial({ color: 0x0077be, transparent: true, opacity: 0.7 })
            );
            pond.rotation.x = -Math.PI / 2;
            
            const shore = new THREE.Mesh(
                new THREE.PlaneGeometry(width + 20, height + 20),
                new THREE.MeshPhongMaterial({ color: 0xc2b280 })
            );
            shore.rotation.x = -Math.PI / 2;
            shore.position.y = -0.05;
            
            pondGroup.add(shore);
            pondGroup.add(pond);
            
            return pondGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º–æ—Å—Ç–∞
        function createBridge() {
            const bridgeGroup = new THREE.Group();
            
            const bridgeDeck = new THREE.Mesh(
                new THREE.BoxGeometry(20, 2, 50),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            bridgeDeck.position.set(400, 5, -200);
            bridgeGroup.add(bridgeDeck);

            // –û–ø–æ—Ä—ã –º–æ—Å—Ç–∞
            for (let i = 0; i < 3; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1.5, 10, 8),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                pillar.position.set(400, 0, -220 + i * 20);
                bridgeGroup.add(pillar);
            }

            return bridgeGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ—á–Ω–æ–π –º–æ–¥–µ–ª–∏ –ß–ê–≠–°
        function createExactChernobylPlant() {
            const plantGroup = new THREE.Group();
            plantGroup.name = "Chernobyl_Plant_Exact";
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888888,
                transparent: true,
                opacity: 0.6,
                roughness: 0.8,
                shininess: 20
            });
            
            const reactorMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.7,
                metalness: 0.4,
                roughness: 0.5
            });

            // –≠–Ω–µ—Ä–≥–æ–±–ª–æ–∫–∏
            const unit1Group = createUnit1();
            unit1Group.position.set(-240, 0, 0);
            
            const unit2Group = createUnit2();
            unit2Group.position.set(-160, 0, 0);
            
            const unit3Group = createUnit3();
            unit3Group.position.set(-80, 0, 0);
            
            const unit4Group = createUnit4();
            unit4Group.position.set(0, 0, 0);
            
            // –ú–æ—Å—Ç—ã-–ø–µ—Ä–µ—Ö–æ–¥—ã
            const bridgeBetween1and2 = createBridgeBetweenUnits();
            bridgeBetween1and2.position.set(-200, 0, 0);
            
            const bridgeBetween2and3 = createBridgeBetweenUnits();
            bridgeBetween2and3.position.set(-120, 0, 0);
            
            const bridgeBetween3and4 = createBridgeBetweenUnits();
            bridgeBetween3and4.position.set(-40, 0, 0);
            
            // –í–µ–Ω—Ç–∏–ª—è—Ü–∏–æ–Ω–Ω—ã–µ —Ç—Ä—É–±—ã —Å –∫—Ä–∞—Å–Ω—ã–º–∏ –ø–æ–ª–æ—Å–∞–º–∏
            const tallVentStack = createTallVentStack();
            tallVentStack.position.set(-280, 0, -40);
            
            const ventStackBetween3and4 = createVentStackBetweenUnits();
            ventStackBetween3and4.position.set(-60, 0, -40);
            
            // –ú–∞—à–∏–Ω–Ω—ã–π –∑–∞–ª —Å –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ–º
            const machineHall = createLongMachineHall();
            machineHall.position.set(-120, 0, -40);
            
            // 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            const unit4MainGroup = new THREE.Group();
            unit4MainGroup.name = "Unit_4_Main_Building";
            
            const reactorHall = createReactorHallExact(buildingMaterial);
            reactorHall.position.y = 21;
            
            const reactorInterior = createReactorInterior(reactorMaterial);
            reactorInterior.position.y = 5;
            
            const pipelines = createPipelines();
            
            const ventStack = createVentStackExact();
            ventStack.position.set(-40, 63, -20);
            
            const deaeratorStack = createDeaeratorStack(buildingMaterial);
            deaeratorStack.position.set(-30, 18, 30);
            
            const auxiliaryBuildings = createAuxiliaryBuildings(buildingMaterial);
            
            const coolingTowers = createHyperboloidCoolingTowers();
            
            const roadsAndLights = createRoadsAndLights();
            
            const windows = createWindowsWithLighting();
            
            const fireStation = createFireStation();
            fireStation.position.set(-200, 0, -100);
            
            const busStop = createBusStop();
            busStop.position.set(80, 0, -60);
            
            // –°–±–æ—Ä–∫–∞
            unit4MainGroup.add(reactorHall);
            unit4MainGroup.add(reactorInterior);
            unit4MainGroup.add(pipelines);
            unit4MainGroup.add(ventStack);
            unit4MainGroup.add(deaeratorStack);
            unit4MainGroup.add(windows);
            
            plantGroup.add(unit1Group);
            plantGroup.add(unit2Group);
            plantGroup.add(bridgeBetween1and2);
            plantGroup.add(bridgeBetween2and3);
            plantGroup.add(unit3Group);
            plantGroup.add(bridgeBetween3and4);
            plantGroup.add(unit4Group);
            plantGroup.add(unit4MainGroup);
            plantGroup.add(tallVentStack);
            plantGroup.add(ventStackBetween3and4);
            plantGroup.add(machineHall);
            plantGroup.add(auxiliaryBuildings);
            plantGroup.add(coolingTowers);
            plantGroup.add(roadsAndLights);
            plantGroup.add(fireStation);
            plantGroup.add(busStop);
            
            return plantGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫–æ–≤ —Å –æ–∫–Ω–∞–º–∏ (6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞)
        function createUnit1() {
            const unitGroup = new THREE.Group();
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(72, 48, 72),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            mainBuilding.position.set(0, 24, 0);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ 1-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫ - –ø–æ 6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —Ñ–∞—Å–∞–¥–µ (6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞)
            for (let row = 0; row < 2; row++) {
                for (let i = 0; i < 6; i++) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(6, 6, 0.5),
                        windowMaterial
                    );
                    window.position.set(
                        -24 + i * 9.6,
                        12 + row * 18,
                        36.1
                    );
                    unitGroup.add(window);
                }
            }
            
            // –ë–µ–ª—ã–µ –ø–æ–ª–æ—Å—ã —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –ø–æ–∂–∞—Ä–Ω–æ–π —á–∞—Å—Ç–∏ (—é–∂–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const stripe1 = new THREE.Mesh(new THREE.BoxGeometry(72, 2, 2), stripeMaterial);
            stripe1.position.set(0, 15, 36);
            const stripe2 = new THREE.Mesh(new THREE.BoxGeometry(72, 2, 2), stripeMaterial);
            stripe2.position.set(0, 35, 36);
            
            unitGroup.add(mainBuilding);
            unitGroup.add(stripe1);
            unitGroup.add(stripe2);
            return unitGroup;
        }

        function createUnit2() {
            const unitGroup = new THREE.Group();
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(72, 48, 72),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            mainBuilding.position.set(0, 24, 0);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ 2-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫ - –ø–æ 6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —Ñ–∞—Å–∞–¥–µ (6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞)
            for (let row = 0; row < 2; row++) {
                for (let i = 0; i < 6; i++) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(6, 6, 0.5),
                        windowMaterial
                    );
                    window.position.set(
                        -24 + i * 9.6,
                        12 + row * 18,
                        36.1
                    );
                    unitGroup.add(window);
                }
            }
            
            // –ë–µ–ª—ã–µ –ø–æ–ª–æ—Å—ã —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –ø–æ–∂–∞—Ä–Ω–æ–π —á–∞—Å—Ç–∏ (—é–∂–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const stripe1 = new THREE.Mesh(new THREE.BoxGeometry(72, 2, 2), stripeMaterial);
            stripe1.position.set(0, 15, 36);
            const stripe2 = new THREE.Mesh(new THREE.BoxGeometry(72, 2, 2), stripeMaterial);
            stripe2.position.set(0, 35, 36);
            
            unitGroup.add(mainBuilding);
            unitGroup.add(stripe1);
            unitGroup.add(stripe2);
            return unitGroup;
        }

        function createUnit3() {
            const unitGroup = new THREE.Group();
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(72, 42, 72),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            building.position.set(0, 21, 0);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ 3-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫ - –ø–æ 6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —Ñ–∞—Å–∞–¥–µ (6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞)
            for (let row = 0; row < 2; row++) {
                for (let i = 0; i < 6; i++) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(6, 6, 0.5),
                        windowMaterial
                    );
                    window.position.set(
                        -24 + i * 9.6,
                        9 + row * 15,
                        36.1
                    );
                    unitGroup.add(window);
                }
            }
            
            unitGroup.add(building);
            return unitGroup;
        }

        function createUnit4() {
            const unitGroup = new THREE.Group();
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(72, 42, 72),
                new THREE.MeshPhongMaterial({ color: 0x666666, transparent: true, opacity: 0.4 })
            );
            building.position.set(0, 21, 0);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫ - –ø–æ 6 –æ–∫–æ–Ω –≤ –¥–≤–∞ —Ä—è–¥–∞ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
            // –£–ë–†–ê–ù–´ –û–ö–ù–ê –ù–ê –ö–†–´–®–ï - –æ—Å—Ç–∞–ª–∏—Å—å —Ç–æ–ª—å–∫–æ –æ–∫–Ω–∞ –Ω–∞ —Å—Ç–µ–Ω–∞—Ö
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —Ñ–∞—Å–∞–¥–µ (6 –æ–∫–æ–Ω –≤ –æ–¥–∏–Ω —Ä—è–¥ - —É–±—Ä–∞–Ω—ã –æ–∫–Ω–∞ –Ω–∞ –∫—Ä—ã—à–µ)
            for (let i = 0; i < 6; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 6, 0.5),
                    windowMaterial
                );
                window.position.set(
                    -24 + i * 9.6,
                    9,
                    36.1
                );
                unitGroup.add(window);
            }
            
            unitGroup.add(building);
            return unitGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞–∑—Ä—É—à–µ–Ω–Ω–æ–≥–æ 4-–≥–æ —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫–∞ —Å —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –¥—ã—Ä–æ–π –≤ –∫—Ä—ã—à–µ
        function createDestroyedUnit4() {
            const destroyedGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ —Ä–∞–∑—Ä—É—à–µ–Ω–Ω–æ–≥–æ –∑–¥–∞–Ω–∏—è
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(72, 10, 72),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            base.position.y = 5;
            destroyedGroup.add(base);
            
            // –û–±–ª–æ–º–∫–∏ –∏ —Ä–∞–∑—Ä—É—à–µ–Ω–Ω—ã–µ —Å—Ç–µ–Ω—ã
            for (let i = 0; i < 20; i++) {
                const debris = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        3 + Math.random() * 8,
                        1 + Math.random() * 4,
                        2 + Math.random() * 6
                    ),
                    new THREE.MeshPhongMaterial({ color: 0x666666 })
                );
                
                debris.position.set(
                    (Math.random() - 0.5) * 60,
                    5 + Math.random() * 10,
                    (Math.random() - 0.5) * 60
                );
                
                debris.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                destroyedGroup.add(debris);
            }
            
            // –î—ã—Ä—ã –≤ —Å—Ç–µ–Ω–∞—Ö
            for (let i = 0; i < 12; i++) {
                const hole = new THREE.Mesh(
                    new THREE.BoxGeometry(6 + Math.random() * 4, 4 + Math.random() * 3, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x000000 })
                );
                
                // –°–ª—É—á–∞–π–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –¥—ã—Ä –≤ —Å—Ç–µ–Ω–∞—Ö
                const side = Math.floor(Math.random() * 4);
                let x, y, z, rotation;
                
                switch(side) {
                    case 0: // –§–∞—Å–∞–¥
                        x = -30 + Math.random() * 60;
                        y = 8 + Math.random() * 20;
                        z = 36.1;
                        rotation = 0;
                        break;
                    case 1: // –ó–∞–¥–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞
                        x = -30 + Math.random() * 60;
                        y = 8 + Math.random() * 20;
                        z = -36.1;
                        rotation = 0;
                        break;
                    case 2: // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
                        x = -36.1;
                        y = 8 + Math.random() * 20;
                        z = -30 + Math.random() * 60;
                        rotation = Math.PI / 2;
                        break;
                    case 3: // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
                        x = 36.1;
                        y = 8 + Math.random() * 20;
                        z = -30 + Math.random() * 60;
                        rotation = Math.PI / 2;
                        break;
                }
                
                hole.position.set(x, y, z);
                hole.rotation.y = rotation;
                destroyedGroup.add(hole);
            }
            
            // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –¥—ã—Ä–∞ –≤ –∫—Ä—ã—à–µ - –±–æ–ª—å—à–∞—è –∏ –Ω–µ—Ä–æ–≤–Ω–∞—è
            const roofHoleGeometry = new THREE.BoxGeometry(35, 0.5, 35);
            const roofHoleMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const roofHole = new THREE.Mesh(roofHoleGeometry, roofHoleMaterial);
            roofHole.position.set(0, 21, 0);
            
            // –î–µ–ª–∞–µ–º –¥—ã—Ä—É –Ω–µ—Ä–æ–≤–Ω–æ–π
            roofHole.scale.set(1, 1, 0.8);
            roofHole.rotation.x = Math.PI / 8;
            roofHole.rotation.z = Math.PI / 12;
            
            destroyedGroup.add(roofHole);
            
            // –û–±–ª–æ–º–∫–∏ –≤–æ–∫—Ä—É–≥ –¥—ã—Ä—ã
            for (let i = 0; i < 8; i++) {
                const edgeDebris = new THREE.Mesh(
                    new THREE.BoxGeometry(2 + Math.random() * 4, 1 + Math.random() * 2, 2 + Math.random() * 3),
                    new THREE.MeshPhongMaterial({ color: 0x555555 })
                );
                
                const angle = (i / 8) * Math.PI * 2;
                const radius = 18;
                
                edgeDebris.position.set(
                    Math.cos(angle) * radius,
                    21 + Math.random() * 3,
                    Math.sin(angle) * radius * 0.8
                );
                
                edgeDebris.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                destroyedGroup.add(edgeDebris);
            }
            
            return destroyedGroup;
        }

        function createBridgeBetweenUnits() {
            const bridgeGroup = new THREE.Group();
            const bridge = new THREE.Mesh(
                new THREE.BoxGeometry(40, 8, 10),
                new THREE.MeshPhongMaterial({ color: 0x444444 })
            );
            bridge.position.set(0, 28, 0);
            bridgeGroup.add(bridge);
            return bridgeGroup;
        }

        function createTallVentStack() {
            const stackGroup = new THREE.Group();
            const stack = new THREE.Mesh(
                new THREE.CylinderGeometry(3, 4, 150, 32),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            stackGroup.add(stack);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            for (let i = 0; i < 6; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.CylinderGeometry(3.1, 4.1, 5, 32),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                stripe.position.y = -60 + i * 25;
                stackGroup.add(stripe);
            }
            
            return stackGroup;
        }

        function createVentStackBetweenUnits() {
            const stackGroup = new THREE.Group();
            const stack = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 2, 40, 32),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            stackGroup.add(stack);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.6, 2.1, 2, 32),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                stripe.position.y = -15 + i * 15;
                stackGroup.add(stripe);
            }
            
            return stackGroup;
        }

        function createLongMachineHall() {
            const hallGroup = new THREE.Group();
            const hall = new THREE.Mesh(
                new THREE.BoxGeometry(320, 24, 30),
                new THREE.MeshPhongMaterial({ color: 0x222222, transparent: true, opacity: 0.8 })
            );
            hall.position.set(0, 12, 0);
            hallGroup.add(hall);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ –≤ –º–∞—à–∏–Ω–Ω—ã–π –∑–∞–ª
            for (let i = 0; i < 8; i++) {
                const equipment = createRealisticTurbine();
                equipment.position.set(-140 + i * 40, 12, 0);
                equipment.userData = {
                    rotationSpeed: 0.01 + Math.random() * 0.02,
                    oscillationSpeed: 0.02 + Math.random() * 0.03,
                    originalY: 12,
                    active: true
                };
                machineHallEquipment.push(equipment);
                hallGroup.add(equipment);
            }
            
            return hallGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π —Ç—É—Ä–±–∏–Ω—ã
        function createRealisticTurbine() {
            const turbineGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ —Ç—É—Ä–±–∏–Ω—ã
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(12, 2, 8),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            base.position.y = 1;
            turbineGroup.add(base);
            
            // –ö–æ—Ä–ø—É—Å —Ç—É—Ä–±–∏–Ω—ã
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(3, 3, 6, 16),
                new THREE.MeshPhongMaterial({ color: 0x3366cc })
            );
            body.position.y = 4;
            turbineGroup.add(body);
            
            // –í—Ä–∞—â–∞—é—â–∏–π—Å—è —Ä–æ—Ç–æ—Ä
            const rotor = new THREE.Mesh(
                new THREE.CylinderGeometry(2.5, 2.5, 5, 12),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            rotor.position.y = 4;
            rotor.userData = { rotationSpeed: 0.1 };
            turbineGroup.add(rotor);
            
            // –ü–æ–¥—à–∏–ø–Ω–∏–∫–∏
            for (let i = 0; i < 2; i++) {
                const bearing = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1, 1, 8),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                bearing.position.set(0, 4, -2 + i * 4);
                turbineGroup.add(bearing);
            }
            
            return turbineGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Å–æ—Å–∞
        function createPump() {
            const pumpGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –Ω–∞—Å–æ—Å–∞
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 4),
                new THREE.MeshPhongMaterial({ color: 0x444444 })
            );
            base.position.y = 0.5;
            pumpGroup.add(base);
            
            // –ö–æ—Ä–ø—É—Å –Ω–∞—Å–æ—Å–∞
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 3, 12),
                new THREE.MeshPhongMaterial({ color: 0x2266aa })
            );
            body.position.y = 2;
            pumpGroup.add(body);
            
            // –≠–ª–µ–∫—Ç—Ä–æ–¥–≤–∏–≥–∞—Ç–µ–ª—å
            const motor = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.2, 2, 12),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            motor.position.set(0, 2, 2);
            pumpGroup.add(motor);
            
            return pumpGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä–æ–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
        function createSteamGenerator() {
            const generatorGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(6, 1, 6),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            base.position.y = 0.5;
            generatorGroup.add(base);
            
            // –ö–æ—Ä–ø—É—Å –ø–∞—Ä–æ–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2, 8, 16),
                new THREE.MeshPhongMaterial({ color: 0x4477cc })
            );
            body.position.y = 4;
            generatorGroup.add(body);
            
            // –¢–µ–ø–ª–æ–æ–±–º–µ–Ω–Ω—ã–µ —Ç—Ä—É–±—ã
            for (let i = 0; i < 4; i++) {
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 6, 8),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                pipe.position.set(-1.5 + i, 4, 0);
                pipe.rotation.z = Math.PI / 2;
                generatorGroup.add(pipe);
            }
            
            return generatorGroup;
        }

        function createReactorHallExact(material) {
            const hallGroup = new THREE.Group();
            const structure = new THREE.Mesh(new THREE.BoxGeometry(72, 42, 72), material);
            hallGroup.add(structure);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ —Ä–µ–∞–∫—Ç–æ—Ä–Ω—ã–π –∑–∞–ª - –ø–æ 6 –æ–∫–æ–Ω –≤ –æ–¥–∏–Ω —Ä—è–¥ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
            // –£–ë–†–ê–ù–´ –û–ö–ù–ê –ù–ê –ö–†–´–®–ï
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —Ñ–∞—Å–∞–¥–µ (6 –æ–∫–æ–Ω –≤ –æ–¥–∏–Ω —Ä—è–¥ - —É–±—Ä–∞–Ω—ã –æ–∫–Ω–∞ –Ω–∞ –∫—Ä—ã—à–µ)
            for (let i = 0; i < 6; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 6, 0.5),
                    windowMaterial
                );
                window.position.set(
                    -24 + i * 9.6,
                    9,
                    36.1
                );
                hallGroup.add(window);
            }
            
            return hallGroup;
        }

        function createReactorInterior(material) {
            const interiorGroup = new THREE.Group();
            
            // –ö–æ—Ä–ø—É—Å —Ä–µ–∞–∫—Ç–æ—Ä–∞
            const reactor = new THREE.Mesh(new THREE.CylinderGeometry(8, 10, 12, 16), material);
            reactor.position.y = 6;
            interiorGroup.add(reactor);
            
            // –°–æ–∑–¥–∞–µ–º —Å—Ç–µ—Ä–∂–Ω–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ —Ä–µ–∞–∫—Ç–æ—Ä–∞
            createReactorRods(interiorGroup);
            
            // –£–ë–†–ê–ù –ø–∞—Ä –≤–Ω—É—Ç—Ä–∏ —Ä–µ–∞–∫—Ç–æ—Ä–∞ (—É–±—Ä–∞–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è createReactorSteam)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞—Å–æ—Å—ã –∏ –ø–∞—Ä–æ–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –≤–æ–∫—Ä—É–≥ —Ä–µ–∞–∫—Ç–æ—Ä–∞
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const radius = 15;
                
                const pump = createPump();
                pump.position.set(
                    Math.cos(angle) * radius,
                    1,
                    Math.sin(angle) * radius
                );
                interiorGroup.add(pump);
                
                const generator = createSteamGenerator();
                generator.position.set(
                    Math.cos(angle + Math.PI/4) * (radius + 5),
                    4,
                    Math.sin(angle + Math.PI/4) * (radius + 5)
                );
                interiorGroup.add(generator);
            }
            
            return interiorGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ—Ä–∂–Ω–µ–π —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Ä–µ–∞–∫—Ç–æ—Ä–µ
        function createReactorRods(interiorGroup) {
            for (let i = 0; i < 12; i++) {
                const rod = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x222222 })
                );
                
                const angle = (i / 12) * Math.PI * 2;
                const radius = 5;
                
                rod.position.set(
                    Math.cos(angle) * radius,
                    4,
                    Math.sin(angle) * radius
                );
                
                rod.userData = {
                    type: 'control_rod',
                    active: true
                };
                
                reactorRods.push(rod);
                interiorGroup.add(rod);
            }
        }

        function createPipelines() {
            const pipelineGroup = new THREE.Group();
            return pipelineGroup;
        }

        function createVentStackExact() {
            const stackGroup = new THREE.Group();
            const stack = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.5, 50, 32),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            stackGroup.add(stack);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.1, 2.6, 3, 32),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                stripe.position.y = -20 + i * 20;
                stackGroup.add(stripe);
            }
            
            return stackGroup;
        }

        function createDeaeratorStack(material) {
            return new THREE.Mesh(new THREE.BoxGeometry(22, 36, 14), material);
        }

        function createAuxiliaryBuildings(material) {
            const auxGroup = new THREE.Group();
            const building = new THREE.Mesh(new THREE.BoxGeometry(40, 12, 25), material);
            building.position.set(10, 6, -35);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∑–¥–∞–Ω–∏—è
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 2; j++) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 0.1),
                        windowMaterial
                    );
                    window.position.set(
                        10 - 15 + i * 10,
                        3 + j * 5,
                        -35 + 12.6
                    );
                    auxGroup.add(window);
                }
            }
            
            auxGroup.add(building);
            return auxGroup;
        }

        function createHyperboloidCoolingTowers() {
            const towersGroup = new THREE.Group();
            for (let i = 0; i < 2; i++) {
                const points = [];
                const height = 80;
                for (let j = 0; j <= 30; j++) {
                    const t = j / 30;
                    const y = (t - 0.5) * height;
                    const radius = 20 + Math.pow(Math.sin(t * Math.PI), 2) * 15;
                    points.push(new THREE.Vector2(radius, y));
                }
                const geometry = new THREE.LatheGeometry(points, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const tower = new THREE.Mesh(geometry, material);
                tower.position.set(100 + i * 80, 40, 80);
                
                // –£–ë–†–ê–ù –ø–∞—Ä –∏–∑ –≥—Ä–∞–¥–∏—Ä–µ–Ω –ê–≠–°
                
                towersGroup.add(tower);
            }
            return towersGroup;
        }

        function createWindowsWithLighting() {
            const windowsGroup = new THREE.Group();
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ –≤—Å–µ –∑–¥–∞–Ω–∏—è —Å—Ç–∞–Ω—Ü–∏–∏ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffaa, 
                transparent: true, 
                opacity: 0.8,
                emissive: 0xffffaa,
                emissiveIntensity: 0.3
            });
            
            // –û–∫–Ω–∞ –Ω–∞ —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫–∞—Ö
            for (let unit = 1; unit <= 4; unit++) {
                // –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä—è–¥ –æ–∫–æ–Ω (—É–±—Ä–∞–Ω—ã –æ–∫–Ω–∞ –Ω–∞ –∫—Ä—ã—à–µ)
                for (let i = 0; i < 6; i++) {
                    for (let side = 0; side < 4; side++) {
                        let x, y, z, rotation;
                        
                        switch(side) {
                            case 0: // –§–∞—Å–∞–¥
                                x = -240 + (unit-1)*80 + (-24 + i * 9.6);
                                y = 9;
                                z = 36.1;
                                rotation = 0;
                                break;
                            case 1: // –ó–∞–¥–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞
                                x = -240 + (unit-1)*80 + (-24 + i * 9.6);
                                y = 9;
                                z = -36.1;
                                rotation = 0;
                                break;
                            case 2: // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
                                x = -240 + (unit-1)*80 - 36.1;
                                y = 9;
                                z = -24 + i * 9.6;
                                rotation = Math.PI / 2;
                                break;
                            case 3: // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
                                x = -240 + (unit-1)*80 + 36.1;
                                y = 9;
                                z = -24 + i * 9.6;
                                rotation = Math.PI / 2;
                                break;
                        }
                        
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(6, 6, 0.1),
                            windowMaterial
                        );
                        window.position.set(x, y, z);
                        window.rotation.y = rotation;
                        buildingLights.push(window);
                        windowsGroup.add(window);
                    }
                }
            }
            
            return windowsGroup;
        }

        function createRoadsAndLights() {
            const roadsGroup = new THREE.Group();
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            const fireTruckRoad = new THREE.Mesh(new THREE.BoxGeometry(250, 0.2, 8), roadMaterial);
            fireTruckRoad.position.set(-100, 0.1, -50);
            fireTruckRoad.rotation.y = Math.PI / 2;
            roadsGroup.add(fireTruckRoad);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ–Ω–∞—Ä–∏ –≤–æ–∫—Ä—É–≥ —Å—Ç–∞–Ω—Ü–∏–∏
            const lightPositions = [
                {x: -150, z: -80}, {x: -100, z: -80}, {x: -50, z: -80}, {x: 0, z: -80}, {x: 50, z: -80}, {x: 100, z: -80}, {x: 150, z: -80},
                {x: -150, z: 80}, {x: -100, z: 80}, {x: -50, z: 80}, {x: 0, z: 80}, {x: 50, z: 80}, {x: 100, z: 80}, {x: 150, z: 80},
                {x: -180, z: -50}, {x: -180, z: 0}, {x: -180, z: 50},
                {x: 180, z: -50}, {x: 180, z: 0}, {x: 180, z: 50}
            ];
            
            lightPositions.forEach(pos => {
                const light = createStreetLight();
                light.position.set(pos.x, 0, pos.z);
                streetLights.push(light);
                roadsGroup.add(light);
            });
            
            return roadsGroup;
        }

        function createFireStation() {
            const stationGroup = new THREE.Group();
            const building = new THREE.Mesh(new THREE.BoxGeometry(30, 10, 20), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            building.position.y = 5;
            stationGroup.add(building);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≥–∞—Ä–∞–∂ –¥–ª—è –ø–æ–∂–∞—Ä–Ω—ã—Ö –º–∞—à–∏–Ω
            const garage = new THREE.Mesh(new THREE.BoxGeometry(25, 8, 15), new THREE.MeshPhongMaterial({ color: 0xcc0000 }));
            garage.position.set(0, 4, -8);
            stationGroup.add(garage);
            
            return stationGroup;
        }

        function createBusStop() {
            const stopGroup = new THREE.Group();
            const roof = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 4), new THREE.MeshPhongMaterial({ color: 0x3366cc }));
            roof.position.set(0, 3, 0);
            stopGroup.add(roof);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∑–Ω–∞–∫ –∞–≤—Ç–æ–±—É—Å–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 3, 2),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            sign.position.set(0, 1.5, 0);
            stopGroup.add(sign);
            
            return stopGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
        function createCity() {
            const cityGroup = new THREE.Group();
            cityGroup.position.set(200, 0, -300);
            
            // –î–æ—Ä–æ–≥–∏ –≥–æ—Ä–æ–¥–∞
            const roadsGroup = createCityRoads();
            cityGroup.add(roadsGroup);

            // –ì–æ—Ä–æ–¥—Å–∫–∏–µ –∑–¥–∞–Ω–∏—è
            const buildingsGroup = createCityBuildings();
            cityGroup.add(buildingsGroup);

            // –î–µ—Ä–µ–≤—å—è
            const treesGroup = createCityTrees();
            cityGroup.add(treesGroup);

            // –§–æ–Ω–∞—Ä–∏
            const lightsGroup = createCityLights();
            cityGroup.add(lightsGroup);

            // –î–æ–±–∞–≤–ª—è–µ–º –ª—é–¥–µ–π –∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –≤ –≥–æ—Ä–æ–¥
            const cityPeopleAndVehicles = createCityPeopleAndVehicles();
            cityGroup.add(cityPeopleAndVehicles);

            // –≠–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ –≥–æ—Ä–æ–¥–µ
            const evacuationStop = createEvacuationStop();
            evacuationStop.position.set(120, 0, -280);
            cityGroup.add(evacuationStop);

            return cityGroup;
        }

        function createCityRoads() {
            const roadsGroup = new THREE.Group();
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const sidewalkMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

            // –ì–ª–∞–≤–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
            const mainRoad1 = new THREE.Mesh(new THREE.BoxGeometry(500, 0.2, 20), roadMaterial);
            mainRoad1.position.set(200, 0.1, -300);
            roadsGroup.add(mainRoad1);

            const mainRoad2 = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 500), roadMaterial);
            mainRoad2.position.set(200, 0.1, -300);
            roadsGroup.add(mainRoad2);

            // –¢—Ä–æ—Ç—É–∞—Ä—ã –≤–¥–æ–ª—å –≥–ª–∞–≤–Ω—ã—Ö –¥–æ—Ä–æ–≥
            for (let i = 0; i < 4; i++) {
                const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(500, 0.2, 2), sidewalkMaterial);
                let x, z;
                
                if (i === 0) {
                    x = 200;
                    z = -295;
                } else if (i === 1) {
                    x = 200;
                    z = -305;
                } else if (i === 2) {
                    x = 195;
                    z = -300;
                    sidewalk.rotation.y = Math.PI / 2;
                } else {
                    x = 205;
                    z = -300;
                    sidewalk.rotation.y = Math.PI / 2;
                }
                
                sidewalk.position.set(x, 0.1, z);
                roadsGroup.add(sidewalk);
            }

            // –ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∏ —Å —Ç—Ä–æ—Ç—É–∞—Ä–∞–º–∏
            const crosswalks = [
                {x: 120, z: -300, width: 8, height: 2},
                {x: 160, z: -300, width: 8, height: 2},
                {x: 200, z: -340, width: 2, height: 8},
                {x: 200, z: -280, width: 2, height: 8},
                {x: 240, z: -300, width: 8, height: 2},
                {x: 280, z: -300, width: 8, height: 2}
            ];

            crosswalks.forEach(crosswalk => {
                const crosswalkMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(crosswalk.width, 0.2, crosswalk.height),
                    new THREE.MeshPhongMaterial({ color: 0xffffff })
                );
                crosswalkMesh.position.set(crosswalk.x, 0.11, crosswalk.z);
                roadsGroup.add(crosswalkMesh);
            });

            return roadsGroup;
        }

        function createCityBuildings() {
            const buildingsGroup = new THREE.Group();
            
            const buildingPositions = [
                // –ü–µ—Ä–≤—ã–π —Ä–∞–π–æ–Ω - —Ü–µ–Ω—Ç—Ä –≥–æ—Ä–æ–¥–∞
                {x: 120, z: -320, w: 15, h: 25, d: 12},
                {x: 140, z: -320, w: 12, h: 30, d: 10},
                {x: 160, z: -320, w: 18, h: 35, d: 14},
                {x: 180, z: -320, w: 14, h: 28, d: 11},
                {x: 200, z: -320, w: 16, h: 40, d: 13},
                {x: 220, z: -320, w: 13, h: 32, d: 12},
                {x: 240, z: -320, w: 17, h: 38, d: 15},
                {x: 260, z: -320, w: 15, h: 34, d: 13},
                {x: 280, z: -320, w: 14, h: 29, d: 11},
                
                // –í—Ç–æ—Ä–æ–π —Ä–∞–π–æ–Ω - —é–∂–Ω–∞—è —á–∞—Å—Ç—å
                {x: 120, z: -340, w: 16, h: 27, d: 12},
                {x: 140, z: -340, w: 13, h: 31, d: 11},
                {x: 160, z: -340, w: 15, h: 36, d: 13},
                {x: 180, z: -340, w: 17, h: 33, d: 14},
                {x: 200, z: -340, w: 14, h: 39, d: 12},
                {x: 220, z: -340, w: 16, h: 30, d: 13},
                {x: 240, z: -340, w: 18, h: 37, d: 15},
                {x: 260, z: -340, w: 15, h: 32, d: 12},
                {x: 280, z: -340, w: 13, h: 28, d: 11},
                
                // –¢—Ä–µ—Ç–∏–π —Ä–∞–π–æ–Ω - —Å–µ–≤–µ—Ä–Ω–∞—è —á–∞—Å—Ç—å
                {x: 120, z: -360, w: 14, h: 26, d: 12},
                {x: 140, z: -360, w: 16, h: 33, d: 13},
                {x: 160, z: -360, w: 17, h: 37, d: 14},
                {x: 180, z: -360, w: 15, h: 31, d: 12},
                {x: 200, z: -360, w: 18, h: 41, d: 15},
                {x: 220, z: -360, w: 14, h: 29, d: 11},
                {x: 240, z: -360, w: 16, h: 35, d: 13},
                {x: 260, z: -360, w: 13, h: 30, d: 12},
                {x: 280, z: -360, w: 15, h: 34, d: 13},
                
                // –ß–µ—Ç–≤–µ—Ä—Ç—ã–π —Ä–∞–π–æ–Ω - –≤–æ—Å—Ç–æ—á–Ω–∞—è —á–∞—Å—Ç—å
                {x: 300, z: -320, w: 16, h: 32, d: 12},
                {x: 320, z: -320, w: 14, h: 28, d: 11},
                {x: 340, z: -320, w: 18, h: 36, d: 14},
                {x: 300, z: -340, w: 15, h: 31, d: 12},
                {x: 320, z: -340, w: 17, h: 35, d: 13},
                {x: 340, z: -340, w: 13, h: 29, d: 11},
                {x: 300, z: -360, w: 16, h: 33, d: 12},
                {x: 320, z: -360, w: 14, h: 30, d: 11},
                {x: 340, z: -360, w: 18, h: 38, d: 14},
                
                // –ü—è—Ç—ã–π —Ä–∞–π–æ–Ω - –∑–∞–ø–∞–¥–Ω–∞—è —á–∞—Å—Ç—å
                {x: 80, z: -320, w: 15, h: 27, d: 12},
                {x: 60, z: -320, w: 13, h: 31, d: 11},
                {x: 40, z: -320, w: 17, h: 35, d: 13},
                {x: 80, z: -340, w: 14, h: 29, d: 12},
                {x: 60, z: -340, w: 16, h: 33, d: 11},
                {x: 40, z: -340, w: 12, h: 28, d: 13},
                {x: 80, z: -360, w: 15, h: 32, d: 12},
                {x: 60, z: -360, w: 13, h: 30, d: 11},
                {x: 40, z: -360, w: 17, h: 36, d: 13},
            ];

            buildingPositions.forEach(pos => {
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(pos.w, pos.h, pos.d),
                    new THREE.MeshPhongMaterial({ color: 0xffffff })
                );
                building.position.set(pos.x, pos.h/2, pos.z);
                buildingsGroup.add(building);

                // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω—ã —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
                const windowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x88ccff, 
                    transparent: true, 
                    opacity: 0.8 
                });
                
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) {
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 2, 0.1),
                            windowMaterial
                        );
                        window.position.set(
                            pos.x - pos.w/3 + i * (pos.w/3),
                            5 + j * 8,
                            pos.z + pos.d/2 + 0.1
                        );
                        buildingLights.push(window);
                        buildingsGroup.add(window);
                    }
                }
            });

            return buildingsGroup;
        }

        function createCityTrees() {
            const treesGroup = new THREE.Group();
            
            const treePositions = [
                // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ —Ä–∞–π–æ–Ω—ã
                {x: 115, z: -315}, {x: 135, z: -315}, {x: 155, z: -315}, {x: 175, z: -315},
                {x: 195, z: -315}, {x: 215, z: -315}, {x: 235, z: -315}, {x: 255, z: -315},
                {x: 275, z: -315}, {x: 285, z: -315},
                {x: 115, z: -325}, {x: 135, z: -325}, {x: 155, z: -325}, {x: 175, z: -325},
                {x: 195, z: -325}, {x: 215, z: -325}, {x: 235, z: -325}, {x: 255, z: -325},
                {x: 275, z: -325}, {x: 285, z: -325},
                {x: 115, z: -335}, {x: 135, z: -335}, {x: 155, z: -335}, {x: 175, z: -335},
                {x: 195, z: -335}, {x: 215, z: -335}, {x: 235, z: -335}, {x: 255, z: -335},
                {x: 275, z: -335}, {x: 285, z: -335},
                {x: 115, z: -345}, {x: 135, z: -345}, {x: 155, z: -345}, {x: 175, z: -345},
                {x: 195, z: -345}, {x: 215, z: -345}, {x: 235, z: -345}, {x: 255, z: -345},
                {x: 275, z: -345}, {x: 285, z: -345},
                {x: 115, z: -355}, {x: 135, z: -355}, {x: 155, z: -355}, {x: 175, z: -355},
                {x: 195, z: -355}, {x: 215, z: -355}, {x: 235, z: -355}, {x: 255, z: -355},
                {x: 275, z: -355}, {x: 285, z: -355},
                {x: 115, z: -365}, {x: 135, z: -365}, {x: 155, z: -365}, {x: 175, z: -365},
                {x: 195, z: -365}, {x: 215, z: -365}, {x: 235, z: -365}, {x: 255, z: -365},
                {x: 275, z: -365}, {x: 285, z: -365},
                
                // –í–æ—Å—Ç–æ—á–Ω—ã–µ —Ä–∞–π–æ–Ω—ã
                {x: 305, z: -315}, {x: 325, z: -315}, {x: 345, z: -315},
                {x: 305, z: -325}, {x: 325, z: -325}, {x: 345, z: -325},
                {x: 305, z: -335}, {x: 325, z: -335}, {x: 345, z: -335},
                {x: 305, z: -345}, {x: 325, z: -345}, {x: 345, z: -345},
                {x: 305, z: -355}, {x: 325, z: -355}, {x: 345, z: -355},
                {x: 305, z: -365}, {x: 325, z: -365}, {x: 345, z: -365},
                
                // –ó–∞–ø–∞–¥–Ω—ã–µ —Ä–∞–π–æ–Ω—ã
                {x: 75, z: -315}, {x: 55, z: -315}, {x: 35, z: -315},
                {x: 75, z: -325}, {x: 55, z: -325}, {x: 35, z: -325},
                {x: 75, z: -335}, {x: 55, z: -335}, {x: 35, z: -335},
                {x: 75, z: -345}, {x: 55, z: -345}, {x: 35, z: -345},
                {x: 75, z: -355}, {x: 55, z: -355}, {x: 35, z: -355},
                {x: 75, z: -365}, {x: 55, z: -365}, {x: 35, z: -365},
            ];

            treePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                treesGroup.add(tree);
            });

            return treesGroup;
        }

        function createCityLights() {
            const lightsGroup = new THREE.Group();
            
            // –£–ü–†–û–©–ï–ù–ù–ê–Ø –°–ï–¢–¨ –§–û–ù–ê–†–ï–ô - —Ç–æ–ª—å–∫–æ –≤–¥–æ–ª—å –≥–ª–∞–≤–Ω—ã—Ö –¥–æ—Ä–æ–≥
            for (let i = 0; i < 16; i++) {
                const light = createStreetLight();
                light.position.set(120 + i * 15, 0, -295);
                streetLights.push(light);
                lightsGroup.add(light);
                
                const light2 = createStreetLight();
                light2.position.set(120 + i * 15, 0, -305);
                streetLights.push(light2);
                lightsGroup.add(light2);
            }

            return lightsGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ª—é–¥–µ–π –∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –≤ –≥–æ—Ä–æ–¥–µ
        function createCityPeopleAndVehicles() {
            const group = new THREE.Group();
            
            // –õ—é–¥–∏ –≤ –≥–æ—Ä–æ–¥–µ
            for (let i = 0; i < 40; i++) {
                const person = createPerson();
                person.position.set(
                    40 + Math.random() * 320,
                    0.5,
                    -320 + Math.random() * 80
                );
                person.userData = {
                    type: 'city_person',
                    direction: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01),
                    timer: 0,
                    evacuating: false
                };
                cityPeople.push(person);
                group.add(person);
            }

            // –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç –≤ –≥–æ—Ä–æ–¥–µ
            for (let i = 0; i < 15; i++) {
                const vehicle = createCar();
                vehicle.position.set(
                    40 + Math.random() * 320,
                    0.5,
                    -300 + (Math.random() - 0.5) * 20
                );
                vehicle.userData = {
                    type: 'city_vehicle',
                    direction: new THREE.Vector3(0.02, 0, 0),
                    timer: 0
                };
                cityVehicles.push(vehicle);
                group.add(vehicle);
            }

            return group;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∞–≤—Ç–æ–º–æ–±–∏–ª—è
        function createCar() {
            const carGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.5, 2),
                new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff })
            );
            body.position.y = 0.75;
            carGroup.add(body);
            
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 2),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            cabin.position.set(-0.5, 1.25, 0);
            carGroup.add(cabin);
            
            // –ö–æ–ª–µ—Å–∞
            for (let i = 0; i < 4; i++) {
                const wheel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8),
                    new THREE.MeshPhongMaterial({ color: 0x222222 })
                );
                wheel.rotation.z = Math.PI / 2;
                const x = i % 2 === 0 ? -1.2 : 1.2;
                const z = i < 2 ? -0.8 : 0.8;
                wheel.position.set(x, 0.3, z);
                carGroup.add(wheel);
            }
            
            return carGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —ç–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ –≥–æ—Ä–æ–¥–µ
        function createEvacuationStop() {
            const stopGroup = new THREE.Group();
            
            // –ë–æ–ª—å—à–∞—è –∫—Ä—ã—à–∞
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(20, 0.5, 10),
                new THREE.MeshPhongMaterial({ color: 0x3366cc })
            );
            roof.position.set(0, 4, 0);
            stopGroup.add(roof);
            
            // –û–ø–æ—Ä—ã –¥–ª—è –∫—Ä—ã—à–∏
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 4, 8),
                    new THREE.MeshPhongMaterial({ color: 0x666666 })
                );
                const x = i % 2 === 0 ? -8 : 8;
                const z = i < 2 ? -4 : 4;
                pillar.position.set(x, 2, z);
                stopGroup.add(pillar);
            }
            
            // –ë–æ–ª—å—à–æ–π –∑–Ω–∞–∫ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 3),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            sign.position.set(0, 2, 0);
            stopGroup.add(sign);
            
            // –ù–∞–¥–ø–∏—Å—å –Ω–∞ –∑–Ω–∞–∫–µ
            const signText = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 2, 0.1),
                new THREE.MeshPhongMaterial({ color: 0xff0000 })
            );
            signText.position.set(0, 2, 1.6);
            stopGroup.add(signText);
            
            // –°–∫–∞–º–µ–π–∫–∏
            for (let i = 0; i < 2; i++) {
                const bench = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.5, 1),
                    new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                );
                bench.position.set(0, 0.25, -2 + i * 4);
                stopGroup.add(bench);
            }
            
            return stopGroup;
        }

        function createStreetLight() {
            const lightGroup = new THREE.Group();
            
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            
            const lamp = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0xffffaa })
            );
            lamp.position.y = 4;
            
            lightGroup.add(pole);
            lightGroup.add(lamp);
            
            return lightGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å–µ–ª–µ–Ω–∏—è —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
        function createSettlement() {
            const settlementGroup = new THREE.Group();
            settlementGroup.position.set(600, 0, -300);
            
            // –î–æ—Ä–æ–≥–∏ –ø–æ—Å–µ–ª–µ–Ω–∏—è
            const roadsGroup = createSettlementRoads();
            settlementGroup.add(roadsGroup);

            // –ñ–∏–ª—ã–µ –¥–æ–º–∞ —Å –æ–∫–Ω–∞–º–∏
            const housesGroup = createSettlementHouses();
            settlementGroup.add(housesGroup);

            // –î–µ—Ä–µ–≤—å—è –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            const treesGroup = createSettlementTrees();
            settlementGroup.add(treesGroup);

            // –¢–≠–¶
            const powerPlant = createPowerPlant();
            powerPlant.position.set(0, 0, 50);
            settlementGroup.add(powerPlant);

            // –í–æ–¥–æ—ë–º –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏ (—Å–æ–µ–¥–∏–Ω–µ–Ω —Å —Ä–µ–∫–æ–π)
            const settlementPond = createPond(60, 40);
            settlementPond.position.set(50, 0.1, 80);
            settlementGroup.add(settlementPond);

            // –ö–∞–Ω–∞–ª —Å–æ–µ–¥–∏–Ω—è—é—â–∏–π –≤–æ–¥–æ—ë–º —Å —Ä–µ–∫–æ–π
            const canal2 = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 6),
                new THREE.MeshPhongMaterial({ color: 0x0066cc, transparent: true, opacity: 0.8 })
            );
            canal2.rotation.x = -Math.PI / 2;
            canal2.rotation.z = -Math.PI / 6;
            canal2.position.set(80, 0.1, 120);
            settlementGroup.add(canal2);

            // –§–æ–Ω–∞—Ä–∏ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            const settlementLights = createSettlementLights();
            settlementGroup.add(settlementLights);

            // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–ª—è —ç–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∞–≤—Ç–æ–±—É—Å–æ–≤
            const evacuationBusStop = createEvacuationBusStop();
            evacuationBusStop.position.set(80, 0, -50);
            settlementGroup.add(evacuationBusStop);

            // –õ—é–¥–∏ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            const settlementPeopleGroup = createSettlementPeopleAndVehicles();
            settlementGroup.add(settlementPeopleGroup);

            return settlementGroup;
        }

        function createSettlementRoads() {
            const roadsGroup = new THREE.Group();
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });

            // –ì–ª–∞–≤–Ω–∞—è –¥–æ—Ä–æ–≥–∞ —á–µ—Ä–µ–∑ –ø–æ—Å–µ–ª–µ–Ω–∏–µ
            const mainRoad = new THREE.Mesh(new THREE.BoxGeometry(200, 0.2, 8), roadMaterial);
            mainRoad.position.set(0, 0.1, 0);
            roadsGroup.add(mainRoad);

            // –ü–æ–ø–µ—Ä–µ—á–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
            for (let i = 0; i < 3; i++) {
                const crossRoad = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 100), roadMaterial);
                crossRoad.position.set(-60 + i * 60, 0.1, 0);
                roadsGroup.add(crossRoad);
            }

            return roadsGroup;
        }

        function createSettlementHouses() {
            const housesGroup = new THREE.Group();
            
            for (let i = 0; i < 15; i++) {
                const house = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 15, 8),
                    new THREE.MeshPhongMaterial({ color: 0xf0f0f0 })
                );
                house.position.set(
                    -60 + (i % 5) * 30,
                    7.5,
                    -60 + Math.floor(i / 5) * 30
                );
                housesGroup.add(house);

                // –ö—Ä—ã—à–∞
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(8, 4, 4),
                    new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                );
                roof.position.set(
                    -60 + (i % 5) * 30,
                    17,
                    -60 + Math.floor(i / 5) * 30
                );
                housesGroup.add(roof);

                // –û–∫–Ω–∞ –≤ –¥–æ–º–∞—Ö —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
                const windowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffaa, 
                    transparent: true, 
                    opacity: 0.8,
                    emissive: 0xffffaa,
                    emissiveIntensity: 0.3
                });

                for (let j = 0; j < 2; j++) {
                    for (let k = 0; k < 2; k++) {
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1.2, 0.1),
                            windowMaterial
                        );
                        window.position.set(
                            -60 + (i % 5) * 30 - 2 + k * 4,
                            5 + j * 6,
                            -60 + Math.floor(i / 5) * 30 + 4.1
                        );
                        buildingLights.push(window);
                        housesGroup.add(window);
                    }
                }
            }

            return housesGroup;
        }

        function createSettlementTrees() {
            const treesGroup = new THREE.Group();
            
            const treePositions = [
                {x: -70, z: -70}, {x: -40, z: -70}, {x: -10, z: -70}, {x: 20, z: -70}, {x: 50, z: -70},
                {x: -70, z: -40}, {x: 50, z: -40}, {x: -70, z: -10}, {x: 50, z: -10},
                {x: -70, z: 20}, {x: 50, z: 20}, {x: -70, z: 50}, {x: -40, z: 50}, {x: -10, z: 50}, {x: 20, z: 50}, {x: 50, z: 50}
            ];

            treePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                treesGroup.add(tree);
            });

            return treesGroup;
        }

        function createPowerPlant() {
            const plantGroup = new THREE.Group();
            
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(40, 25, 30),
                new THREE.MeshPhongMaterial({ color: 0x888888 })
            );
            mainBuilding.position.y = 12.5;
            plantGroup.add(mainBuilding);

            // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫–Ω–∞ –Ω–∞ –¢–≠–¶
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffaa, 
                transparent: true, 
                opacity: 0.8,
                emissive: 0xffffaa,
                emissiveIntensity: 0.3
            });
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 0.1),
                        windowMaterial
                    );
                    window.position.set(
                        -15 + i * 10,
                        5 + j * 6,
                        15.1
                    );
                    buildingLights.push(window);
                    plantGroup.add(window);
                }
            }

            // –¢—Ä—É–±–∞ –¢–≠–¶
            const chimney = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.5, 80, 16),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            chimney.position.set(15, 40, 0);
            plantGroup.add(chimney);

            // –ö—Ä–∞—Å–Ω—ã–µ –ø–æ–ª–æ—Å—ã –Ω–∞ —Ç—Ä—É–±–µ
            for (let i = 0; i < 4; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.1, 2.6, 3, 16),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                stripe.position.set(15, -20 + i * 20, 0);
                plantGroup.add(stripe);
            }

            // –ì—Ä–∞–¥–∏—Ä–Ω–∏
            for (let i = 0; i < 2; i++) {
                const coolingTower = new THREE.Mesh(
                    new THREE.CylinderGeometry(12, 15, 50, 24),
                    new THREE.MeshPhongMaterial({ color: 0xffffff })
                );
                coolingTower.position.set(-20 + i * 40, 25, 20);
                plantGroup.add(coolingTower);
                
                // –£–ë–†–ê–ù –ø–∞—Ä –∏–∑ –≥—Ä–∞–¥–∏—Ä–µ–Ω –¢–≠–¶ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            }

            return plantGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–ª—è —ç–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∞–≤—Ç–æ–±—É—Å–æ–≤
        function createEvacuationBusStop() {
            const stopGroup = new THREE.Group();
            
            // –ë–æ–ª—å—à–∞—è –∫—Ä—ã—à–∞
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(15, 0.5, 8),
                new THREE.MeshPhongMaterial({ color: 0x3366cc })
            );
            roof.position.set(0, 4, 0);
            stopGroup.add(roof);
            
            // –û–ø–æ—Ä—ã –¥–ª—è –∫—Ä—ã—à–∏
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 4, 8),
                    new THREE.MeshPhongMaterial({ color: 0x666666 })
                );
                const x = i % 2 === 0 ? -6 : 6;
                const z = i < 2 ? -3 : 3;
                pillar.position.set(x, 2, z);
                stopGroup.add(pillar);
            }
            
            // –ë–æ–ª—å—à–æ–π –∑–Ω–∞–∫ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 3),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            sign.position.set(0, 2, 0);
            stopGroup.add(sign);
            
            // –ù–∞–¥–ø–∏—Å—å –Ω–∞ –∑–Ω–∞–∫–µ
            const signText = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 2, 0.1),
                new THREE.MeshPhongMaterial({ color: 0xff0000 })
            );
            signText.position.set(0, 2, 1.6);
            stopGroup.add(signText);
            
            return stopGroup;
        }

        function createSettlementLights() {
            const lightsGroup = new THREE.Group();
            
            // –£–≤–µ–ª–∏—á–∏–ª –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–æ–Ω–∞—Ä–µ–π –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            const lightPositions = [
                {x: -70, z: -70}, {x: -40, z: -70}, {x: -10, z: -70}, {x: 20, z: -70}, {x: 50, z: -70},
                {x: -70, z: -40}, {x: -40, z: -40}, {x: -10, z: -40}, {x: 20, z: -40}, {x: 50, z: -40},
                {x: -70, z: -10}, {x: -40, z: -10}, {x: -10, z: -10}, {x: 20, z: -10}, {x: 50, z: -10},
                {x: -70, z: 20}, {x: -40, z: 20}, {x: -10, z: 20}, {x: 20, z: 20}, {x: 50, z: 20},
                {x: -70, z: 50}, {x: -40, z: 50}, {x: -10, z: 50}, {x: 20, z: 50}, {x: 50, z: 50},
                {x: -60, z: -60}, {x: -30, z: -60}, {x: 0, z: -60}, {x: 30, z: -60}, {x: 60, z: -60},
                {x: -60, z: -30}, {x: 60, z: -30}, {x: -60, z: 0}, {x: 60, z: 0}, {x: -60, z: 30}, {x: 60, z: 30}
            ];
            
            lightPositions.forEach(pos => {
                const light = createStreetLight();
                light.position.set(pos.x, 0, pos.z);
                streetLights.push(light);
                lightsGroup.add(light);
            });

            return lightsGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ª—é–¥–µ–π –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
        function createSettlementPeopleAndVehicles() {
            const group = new THREE.Group();
            
            // –õ—é–¥–∏ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            for (let i = 0; i < 15; i++) {
                const person = createPerson();
                person.position.set(
                    -50 + Math.random() * 100,
                    0.5,
                    -50 + Math.random() * 100
                );
                person.userData = {
                    type: 'person',
                    direction: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01),
                    timer: 0,
                    evacuating: false
                };
                settlementPeople.push(person);
                group.add(person);
            }

            return group;
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function createTree() {
            const treeGroup = new THREE.Group();
            
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.5, 4, 8),
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 2;
            
            const crown = new THREE.Mesh(
                new THREE.SphereGeometry(2, 8, 6),
                new THREE.MeshPhongMaterial({ color: 0x228B22 })
            );
            crown.position.y = 5;
            
            treeGroup.add(trunk);
            treeGroup.add(crown);
            
            return treeGroup;
        }

        function createPerson() {
            const personGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 1.5, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x3366ff })
            );
            body.position.y = 0.75;
            personGroup.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0xffddaa })
            );
            head.position.y = 1.5;
            personGroup.add(head);
            
            return personGroup;
        }

        function createFireTruck() {
            const truckGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(8, 3, 3),
                new THREE.MeshPhongMaterial({ color: 0xff0000 })
            );
            body.position.y = 1.5;
            truckGroup.add(body);
            
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(4, 2.5, 3),
                new THREE.MeshPhongMaterial({ color: 0xff0000 })
            );
            cabin.position.set(-2, 2.25, 0);
            truckGroup.add(cabin);
            
            // –õ–µ—Å—Ç–Ω–∏—Ü–∞
            const ladder = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 6, 2),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            ladder.position.set(3, 4, 0);
            truckGroup.add(ladder);
            
            return truckGroup;
        }

        function createEvacuationBus() {
            const busGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(10, 3, 3),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            body.position.y = 1.5;
            busGroup.add(body);
            
            return busGroup;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –≤–∑—Ä—ã–≤–∞
        function createExplosionEffects() {
            // –í–∑—Ä—ã–≤ - –æ–≥–Ω–µ–Ω–Ω—ã–π —à–∞—Ä
            const explosionGroup = new THREE.Group();
            explosionGroup.position.set(0, 25, 0);
            
            const explosionGeometry = new THREE.SphereGeometry(2, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4500, 
                transparent: true, 
                opacity: 0.9 
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosionGroup.add(explosion);
            
            explosionEffects.push(explosionGroup);
            scene.add(explosionGroup);
            
            // –û–≥–æ–Ω—å
            for (let i = 0; i < 30; i++) {
                const fireGeometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.8, 8, 8);
                const fireMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(0.1 - Math.random() * 0.1, 1, 0.5), 
                    transparent: true, 
                    opacity: 0.8 
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                
                fire.position.set(
                    (Math.random() - 0.5) * 15,
                    20 + Math.random() * 10,
                    (Math.random() - 0.5) * 15
                );
                
                fire.userData = {
                    speed: 0.05 + Math.random() * 0.05,
                    flickerSpeed: 0.1 + Math.random() * 0.1,
                    life: 1.0
                };
                
                fireEffects.push(fire);
                scene.add(fire);
            }
            
            // –î–û–ë–ê–í–õ–ï–ù–û: –ß–µ—Ä–Ω—ã–π –¥—ã–º –ø–æ—Å–ª–µ –≤–∑—Ä—ã–≤–∞
            createBlackSmoke();
            
            // –û—Å–∫–æ–ª–∫–∏
            for (let i = 0; i < 50; i++) {
                const debrisGeometry = new THREE.BoxGeometry(
                    0.5 + Math.random() * 2,
                    0.5 + Math.random() * 2,
                    0.5 + Math.random() * 2
                );
                const debrisMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x888888 
                });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                
                debris.position.set(0, 25, 0);
                
                debris.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.8,
                        (Math.random() - 0.5) * 0.5
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.1,
                        Math.random() * 0.1,
                        Math.random() * 0.1
                    ),
                    life: 3.0
                };
                
                debrisParticles.push(debris);
                scene.add(debris);
            }
            
            // –°–æ–∑–¥–∞–µ–º —Ä–∞–¥–∏–æ–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±–ª–∞–∫–æ –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º
            createRadioactiveCloud();
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ
            startEarthquake();
            
            // –†–∞–∑—Ä—É—à–∞–µ–º 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            destroyUnit4();
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
            stopAllProcesses();
            
            // –í—ã–∑—ã–≤–∞–µ–º –ø–æ–∂–∞—Ä–Ω—ã—Ö
            callFirefighters();
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —ç–≤–∞–∫—É–∞—Ü–∏—é
            startEvacuation();
        }

        // –î–û–ë–ê–í–õ–ï–ù–û: –°–æ–∑–¥–∞–Ω–∏–µ —á–µ—Ä–Ω–æ–≥–æ –¥—ã–º–∞ –ø–æ—Å–ª–µ –≤–∑—Ä—ã–≤–∞
        function createBlackSmoke() {
            for (let i = 0; i < 60; i++) {
                const smokeGeometry = new THREE.SphereGeometry(0.5 + Math.random() * 1.5, 8, 8);
                const smokeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x111111,
                    transparent: true, 
                    opacity: 0.6 
                });
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                
                smoke.position.set(
                    (Math.random() - 0.5) * 20,
                    25 + Math.random() * 10,
                    (Math.random() - 0.5) * 20
                );
                
                smoke.userData = {
                    speed: 0.03 + Math.random() * 0.02,
                    drift: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        0.02 + Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.01
                    ),
                    scaleSpeed: 0.005 + Math.random() * 0.003,
                    life: 1.0
                };
                
                blackSmokeParticles.push(smoke);
                scene.add(smoke);
            }
        }

        // –í—ã–∑–æ–≤ –ø–æ–∂–∞—Ä–Ω—ã—Ö
        function callFirefighters() {
            // –°–æ–∑–¥–∞–µ–º –ø–æ–∂–∞—Ä–Ω—ã–µ –º–∞—à–∏–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã–µ–∑–∂–∞—é—Ç –∏–∑ –ø–æ–∂–∞—Ä–Ω–æ–π —á–∞—Å—Ç–∏
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const fireTruck = createFireTruck();
                    fireTruck.position.set(-200, 0.5, -100);
                    fireTruck.userData = {
                        type: 'fire_truck',
                        speed: 0.15,
                        targetPosition: new THREE.Vector3(-50 + i * 20, 0.5, -50), // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è —Å–Ω–∞—Ä—É–∂–∏ —Å—Ç–∞–Ω—Ü–∏–∏
                        arrived: false
                    };
                    emergencyVehicles.push(fireTruck);
                    scene.add(fireTruck);
                }, i * 1000); // –ú–∞—à–∏–Ω—ã –≤—ã–µ–∑–∂–∞—é—Ç —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞–¥–∏–æ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –æ–±–ª–∞–∫–∞
        function createRadioactiveCloud() {
            const cloudGroup = new THREE.Group();
            
            for (let i = 0; i < 40; i++) {
                const cloudGeometry = new THREE.SphereGeometry(1.5 + Math.random() * 2.5, 8, 8);
                const cloudMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true, 
                    opacity: 0.4 
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                cloud.position.set(
                    180 + (Math.random() - 0.5) * 60,
                    60 + Math.random() * 40,
                    -300 + (Math.random() - 0.5) * 60
                );
                
                cloud.userData = {
                    speed: 0.008 + Math.random() * 0.005,
                    scaleSpeed: 0.001 + Math.random() * 0.001,
                    drift: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        0.005 + Math.random() * 0.005,
                        (Math.random() - 0.5) * 0.01
                    )
                };
                
                cloudGroup.add(cloud);
            }
            
            radioactiveCloud = cloudGroup;
            scene.add(cloudGroup);
        }

        // –ó–∞–ø—É—Å–∫ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏—è
        function startEarthquake() {
            controls.earthquakeActive = true;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤
            const originalPositions = [];
            
            scene.traverse(object => {
                if (object.isMesh && object.position.y > 0) {
                    originalPositions.push({
                        object: object,
                        position: object.position.clone(),
                        rotation: object.rotation.clone()
                    });
                }
            });
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏—è
            let earthquakeTime = 0;
            const earthquakeDuration = 3000; // 3 —Å–µ–∫—É–Ω–¥—ã
            
            function animateEarthquake() {
                if (earthquakeTime < earthquakeDuration) {
                    const intensity = 0.5 * (1 - earthquakeTime / earthquakeDuration);
                    
                    originalPositions.forEach(item => {
                        item.object.position.x = item.position.x + (Math.random() - 0.5) * intensity;
                        item.object.position.y = item.position.y + (Math.random() - 0.5) * intensity;
                        item.object.position.z = item.position.z + (Math.random() - 0.5) * intensity;
                        
                        item.object.rotation.x = item.rotation.x + (Math.random() - 0.5) * intensity * 0.1;
                        item.object.rotation.y = item.rotation.y + (Math.random() - 0.5) * intensity * 0.1;
                        item.object.rotation.z = item.rotation.z + (Math.random() - 0.5) * intensity * 0.1;
                    });
                    
                    earthquakeTime += 16;
                    requestAnimationFrame(animateEarthquake);
                } else {
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
                    originalPositions.forEach(item => {
                        item.object.position.copy(item.position);
                        item.object.rotation.copy(item.rotation);
                    });
                    
                    controls.earthquakeActive = false;
                }
            }
            
            animateEarthquake();
        }

        // –†–∞–∑—Ä—É—à–µ–Ω–∏–µ 4-–≥–æ —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫–∞
        function destroyUnit4() {
            unit4Destroyed = true;
            
            // –ù–∞—Ö–æ–¥–∏–º –∏ —É–¥–∞–ª—è–µ–º 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            scene.traverse(object => {
                if (object.name === "Unit_4_Main_Building" || 
                    (object.parent && object.parent.name === "Unit_4_Main_Building")) {
                    scene.remove(object);
                }
            });
            
            // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º —Å—Ç–µ—Ä–∂–Ω–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            reactorRods.forEach(rod => {
                scene.remove(rod);
            });
            reactorRods = [];
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä –≤ —Ä–µ–∞–∫—Ç–æ—Ä–µ
            steamParticles.forEach(steam => {
                steam.userData.active = false;
            });
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑—Ä—É—à–µ–Ω–Ω—ã–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            destroyedUnit4 = createDestroyedUnit4();
            destroyedUnit4.position.set(0, 0, 0);
            scene.add(destroyedUnit4);
        }

        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
        function stopAllProcesses() {
            controls.processesStopped = true;
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ –≤ –º–∞—à–∏–Ω–Ω–æ–º –∑–∞–ª–µ
            machineHallEquipment.forEach(equipment => {
                equipment.userData.active = false;
            });
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥—ã–º –∏–∑ –¢–≠–¶
            tecSmokeParticles.forEach(smoke => {
                smoke.userData.active = false;
            });
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä –∏–∑ –≥—Ä–∞–¥–∏—Ä–µ–Ω
            coolingTowerSteam.forEach(steam => {
                steam.userData.active = false;
            });
            
            // –í—ã–∫–ª—é—á–∞–µ–º —Å–≤–µ—Ç –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏
            stationLightsOn = false;
            updateStationLights();
        }

        // –ó–∞–ø—É—Å–∫ —ç–≤–∞–∫—É–∞—Ü–∏–∏
        function startEvacuation() {
            evacuationStarted = true;
            
            // –≠–≤–∞–∫—É–∞—Ü–∏—è –ª—é–¥–µ–π —Å–æ —Å—Ç–∞–Ω—Ü–∏–∏
            stationPeople.forEach(person => {
                person.userData.evacuating = true;
                person.userData.direction.set(0.05, 0, -0.05); // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∞–≤—Ç–æ–±—É—Å–∞–º
            });
            
            // –≠–≤–∞–∫—É–∞—Ü–∏—è –ª—é–¥–µ–π –∏–∑ –≥–æ—Ä–æ–¥–∞
            cityPeople.forEach(person => {
                person.userData.evacuating = true;
                // –î–≤–∏–∂–µ–Ω–∏–µ –∫ —ç–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –≤ –≥–æ—Ä–æ–¥–µ
                const directionToStop = new THREE.Vector3(120, 0, -280).sub(person.position).normalize();
                person.userData.direction = directionToStop.multiplyScalar(0.02);
            });
            
            // –°–æ–∑–¥–∞–µ–º –∞–≤—Ç–æ–±—É—Å—ã –¥–ª—è —ç–≤–∞–∫—É–∞—Ü–∏–∏
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const bus = createEvacuationBus();
                    bus.position.set(80 + i * 25, 0.5, -60); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è –Ω–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
                    bus.userData = {
                        type: 'evacuation_bus',
                        speed: 0.08,
                        evacuating: false,
                        peopleLoaded: 0,
                        targetPosition: new THREE.Vector3(680, 0.5, -350) // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
                    };
                    emergencyVehicles.push(bus);
                    scene.add(bus);
                }, i * 2000);
            }
            
            updateStatus("üöå –ù–ê–ß–ê–¢–ê –≠–í–ê–ö–£–ê–¶–ò–Ø", "critical");
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏
        function updateStationLights() {
            buildingLights.forEach(light => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Å–≤–µ—Ç –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏ (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–∫–æ–ª–æ 0,0)
                if (Math.abs(light.position.x) < 200 && Math.abs(light.position.z) < 200) {
                    if (stationLightsOn) {
                        light.material.color.set(0xffffaa);
                        light.material.emissive.set(0xffffaa);
                        light.material.emissiveIntensity = 0.3;
                    } else {
                        light.material.color.set(0x333333);
                        light.material.emissive.set(0x000000);
                        light.material.emissiveIntensity = 0;
                    }
                }
            });
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ª—é–¥–µ–π –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏
        function createStationPeople() {
            const group = new THREE.Group();
            
            // –õ—é–¥–∏ –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏ (—Ä–∞–±–æ—á–∏–µ, –∏–Ω–∂–µ–Ω–µ—Ä—ã)
            for (let i = 0; i < 12; i++) {
                const person = createPerson();
                person.position.set(
                    -100 + Math.random() * 200,
                    0.5,
                    -80 + Math.random() * 160
                );
                person.userData = {
                    type: 'station_person',
                    direction: new THREE.Vector3((Math.random() - 0.5) * 0.015, 0, (Math.random() - 0.5) * 0.015),
                    timer: 0,
                    evacuating: false
                };
                stationPeople.push(person);
                group.add(person);
            }

            return group;
        }

        // –ê–Ω–∏–º–∞—Ü–∏—è –ª—é–¥–µ–π –∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
        function animatePeopleAndVehicles() {
            // –ê–Ω–∏–º–∞—Ü–∏—è –≥–æ—Ä–æ–¥—Å–∫–∏—Ö –ª—é–¥–µ–π
            cityPeople.forEach(person => {
                if (person.userData.evacuating) {
                    person.position.add(person.userData.direction);
                    
                    // –ï—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –¥–æ—Å—Ç–∏–≥ —ç–≤–∞–∫—É–∞—Ü–∏–æ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏, —É–¥–∞–ª—è–µ–º –µ–≥–æ
                    if (person.position.distanceTo(new THREE.Vector3(120, 0, -280)) < 5) {
                        scene.remove(person);
                        cityPeople = cityPeople.filter(p => p !== person);
                    }
                } else {
                    person.userData.timer += 0.1;
                    person.position.add(person.userData.direction);
                    
                    if (person.userData.timer > 40) {
                        person.userData.direction.set(
                            (Math.random() - 0.5) * 0.01,
                            0,
                            (Math.random() - 0.5) * 0.01
                        );
                        person.userData.timer = 0;
                    }
                    
                    if (person.position.x < 40 || person.position.x > 360 || 
                        person.position.z < -320 || person.position.z > -280) {
                        person.position.set(
                            40 + Math.random() * 320,
                            0.5,
                            -320 + Math.random() * 40
                        );
                    }
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –≥–æ—Ä–æ–¥—Å–∫–æ–≥–æ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
            cityVehicles.forEach(vehicle => {
                vehicle.position.add(vehicle.userData.direction);
                
                if (vehicle.position.x > 360) {
                    vehicle.position.x = 40;
                }
                
                vehicle.userData.timer += 0.1;
                if (vehicle.userData.timer > 100) {
                    vehicle.userData.direction.x = -vehicle.userData.direction.x;
                    vehicle.userData.timer = 0;
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –ª—é–¥–µ–π –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
            settlementPeople.forEach(person => {
                if (person.userData.evacuating) {
                    person.position.add(person.userData.direction);
                    
                    // –ï—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –≤—ã—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –ø–æ—Å–µ–ª–µ–Ω–∏—è, —É–¥–∞–ª—è–µ–º –µ–≥–æ
                    if (person.position.x > 100) {
                        scene.remove(person);
                        settlementPeople = settlementPeople.filter(p => p !== person);
                    }
                } else {
                    person.userData.timer += 0.1;
                    person.position.add(person.userData.direction);
                    
                    if (person.userData.timer > 40) {
                        person.userData.direction.set(
                            (Math.random() - 0.5) * 0.01,
                            0,
                            (Math.random() - 0.5) * 0.01
                        );
                        person.userData.timer = 0;
                    }
                    
                    if (person.position.x < -70 || person.position.x > 70 || 
                        person.position.z < -70 || person.position.z > 70) {
                        person.position.set(
                            -50 + Math.random() * 100,
                            0.5,
                            -50 + Math.random() * 100
                        );
                    }
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –ª—é–¥–µ–π –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏
            stationPeople.forEach(person => {
                if (person.userData.evacuating) {
                    person.position.add(person.userData.direction);
                    
                    // –ï—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –¥–æ—Å—Ç–∏–≥ –∞–≤—Ç–æ–±—É—Å–æ–≤, —É–¥–∞–ª—è–µ–º –µ–≥–æ
                    if (person.position.z < -70) {
                        scene.remove(person);
                        stationPeople = stationPeople.filter(p => p !== person);
                    }
                } else {
                    person.userData.timer += 0.1;
                    person.position.add(person.userData.direction);
                    
                    if (person.userData.timer > 25) {
                        person.userData.direction.set(
                            (Math.random() - 0.5) * 0.015,
                            0,
                            (Math.random() - 0.5) * 0.015
                        );
                        person.userData.timer = 0;
                    }
                    
                    if (person.position.x < -120 || person.position.x > 120 || 
                        person.position.z < -100 || person.position.z > 100) {
                        person.position.set(
                            -100 + Math.random() * 200,
                            0.5,
                            -80 + Math.random() * 160
                        );
                    }
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –∞–≤–∞—Ä–∏–π–Ω–æ–π —Ç–µ—Ö–Ω–∏–∫–∏
            emergencyVehicles.forEach(vehicle => {
                if (vehicle.userData.type === 'fire_truck') {
                    if (!vehicle.userData.arrived) {
                        const direction = new THREE.Vector3()
                            .subVectors(vehicle.userData.targetPosition, vehicle.position)
                            .normalize()
                            .multiplyScalar(vehicle.userData.speed);
                        
                        vehicle.position.add(direction);
                        
                        // –ï—Å–ª–∏ –ø–æ–∂–∞—Ä–Ω–∞—è –º–∞—à–∏–Ω–∞ –¥–æ—Å—Ç–∏–≥–ª–∞ —Ü–µ–ª–∏
                        if (vehicle.position.distanceTo(vehicle.userData.targetPosition) < 5) {
                            vehicle.userData.arrived = true;
                            vehicle.userData.speed = 0;
                        }
                    }
                } else if (vehicle.userData.type === 'evacuation_bus') {
                    if (!vehicle.userData.evacuating) {
                        // –ê–≤—Ç–æ–±—É—Å—ã –∂–¥—É—Ç –ª—é–¥–µ–π –Ω–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
                        if (vehicle.position.x < 150) {
                            vehicle.position.x += vehicle.userData.speed * 0.5;
                        }
                        
                        // –ó–∞–≥—Ä—É–∑–∫–∞ –ª—é–¥–µ–π –≤ –∞–≤—Ç–æ–±—É—Å—ã
                        if (stationPeople.length > 0 && vehicle.userData.peopleLoaded < 8) {
                            const nearbyPeople = stationPeople.filter(person => 
                                person.position.distanceTo(vehicle.position) < 10
                            );
                            
                            if (nearbyPeople.length > 0) {
                                const person = nearbyPeople[0];
                                scene.remove(person);
                                stationPeople = stationPeople.filter(p => p !== person);
                                vehicle.userData.peopleLoaded++;
                            }
                        }
                        
                        // –ï—Å–ª–∏ –∞–≤—Ç–æ–±—É—Å –∑–∞–ø–æ–ª–Ω–µ–Ω –∏–ª–∏ –ø—Ä–æ—à–ª–æ –≤—Ä–µ–º—è, —É–µ–∑–∂–∞–µ—Ç –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–µ
                        if (vehicle.userData.peopleLoaded >= 8 || stationPeople.length === 0) {
                            vehicle.userData.evacuating = true;
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∞–≤—Ç–æ–±—É—Å–∞ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–µ
                        const direction = new THREE.Vector3()
                            .subVectors(vehicle.userData.targetPosition, vehicle.position)
                            .normalize()
                            .multiplyScalar(vehicle.userData.speed * 2);
                        
                        vehicle.position.add(direction);
                        
                        // –ï—Å–ª–∏ –∞–≤—Ç–æ–±—É—Å –¥–æ—Å—Ç–∏–≥ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
                        if (vehicle.position.distanceTo(vehicle.userData.targetPosition) < 10) {
                            // –í—ã—Å–∞–∂–∏–≤–∞–µ–º –ª—é–¥–µ–π –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–∏
                            for (let i = 0; i < vehicle.userData.peopleLoaded; i++) {
                                const person = createPerson();
                                person.position.set(
                                    vehicle.position.x + (Math.random() - 0.5) * 10,
                                    0.5,
                                    vehicle.position.z + (Math.random() - 0.5) * 10
                                );
                                person.userData = {
                                    type: 'person',
                                    direction: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01),
                                    timer: 0,
                                    evacuating: false
                                };
                                settlementPeople.push(person);
                                scene.add(person);
                            }
                            
                            vehicle.userData.peopleLoaded = 0;
                            vehicle.userData.evacuating = false;
                            
                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–≤—Ç–æ–±—É—Å –∑–∞ –Ω–æ–≤—ã–º–∏ –ª—é–¥—å–º–∏
                            vehicle.userData.targetPosition = new THREE.Vector3(80, 0.5, -60);
                        }
                    }
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è –≤ –º–∞—à–∏–Ω–Ω–æ–º –∑–∞–ª–µ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å—ã –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã)
            machineHallEquipment.forEach(equipment => {
                if (equipment.userData.active) {
                    equipment.rotation.y += equipment.userData.rotationSpeed;
                    equipment.position.y = equipment.userData.originalY + Math.sin(Date.now() * equipment.userData.oscillationSpeed) * 0.5;
                    
                    // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–æ—Ç–æ—Ä–∞ —Ç—É—Ä–±–∏–Ω—ã
                    equipment.traverse(child => {
                        if (child.userData && child.userData.rotationSpeed) {
                            child.rotation.y += child.userData.rotationSpeed;
                        }
                    });
                }
            });

            // –ê–Ω–∏–º–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –≤–∑—Ä—ã–≤–∞
            if (controls.explosionStarted) {
                // –ê–Ω–∏–º–∞—Ü–∏—è –≤–∑—Ä—ã–≤–∞
                explosionEffects.forEach(explosion => {
                    explosion.scale.x += 0.1;
                    explosion.scale.y += 0.1;
                    explosion.scale.z += 0.1;
                    
                    if (explosion.scale.x > 5) {
                        explosion.scale.set(1, 1, 1);
                    }
                });
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –æ–≥–Ω—è
                fireEffects.forEach(fire => {
                    fire.position.y += fire.userData.speed;
                    fire.scale.x = 1 + Math.sin(Date.now() * fire.userData.flickerSpeed) * 0.3;
                    fire.scale.y = 1 + Math.sin(Date.now() * fire.userData.flickerSpeed) * 0.3;
                    fire.scale.z = 1 + Math.sin(Date.now() * fire.userData.flickerSpeed) * 0.3;
                    
                    fire.userData.life -= 0.01;
                    fire.material.opacity = fire.userData.life * 0.8;
                    
                    if (fire.position.y > 40 || fire.userData.life <= 0) {
                        fire.position.y = 20;
                        fire.userData.life = 1.0;
                    }
                });
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —á–µ—Ä–Ω–æ–≥–æ –¥—ã–º–∞
                blackSmokeParticles.forEach(smoke => {
                    smoke.position.add(smoke.userData.drift);
                    smoke.position.y += smoke.userData.speed;
                    
                    smoke.scale.x += smoke.userData.scaleSpeed;
                    smoke.scale.y += smoke.userData.scaleSpeed;
                    smoke.scale.z += smoke.userData.scaleSpeed;
                    
                    smoke.userData.life -= 0.005;
                    smoke.material.opacity = smoke.userData.life * 0.6;
                    
                    if (smoke.position.y > 80 || smoke.userData.life <= 0) {
                        smoke.position.set(
                            (Math.random() - 0.5) * 20,
                            25 + Math.random() * 10,
                            (Math.random() - 0.5) * 20
                        );
                        smoke.scale.set(1, 1, 1);
                        smoke.userData.life = 1.0;
                    }
                });
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Å–∫–æ–ª–∫–æ–≤
                debrisParticles.forEach(debris => {
                    debris.position.add(debris.userData.velocity);
                    debris.rotation.x += debris.userData.rotationSpeed.x;
                    debris.rotation.y += debris.userData.rotationSpeed.y;
                    debris.rotation.z += debris.userData.rotationSpeed.z;
                    
                    debris.userData.velocity.y -= 0.01; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    debris.userData.life -= 0.01;
                    
                    if (debris.position.y < 0 || debris.userData.life <= 0) {
                        scene.remove(debris);
                        debrisParticles = debrisParticles.filter(d => d !== debris);
                    }
                });
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–¥–∏–æ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –æ–±–ª–∞–∫–∞
                if (radioactiveCloud) {
                    radioactiveCloud.position.y += 0.01;
                    radioactiveCloud.children.forEach(cloud => {
                        cloud.position.add(cloud.userData.drift);
                        cloud.scale.x += cloud.userData.scaleSpeed;
                        cloud.scale.y += cloud.userData.scaleSpeed;
                        cloud.scale.z += cloud.userData.scaleSpeed;
                        
                        if (cloud.position.y > 150) {
                            cloud.position.y = 60;
                            cloud.scale.set(1, 1, 1);
                        }
                    });
                }
            }
        }

        // –°–∏—Å—Ç–µ–º–∞ –æ—Å–≤–µ—â–µ–Ω–∏—è
        function setupLighting() {
            if (sunLight) scene.remove(sunLight);
            if (ambientLight) scene.remove(ambientLight);

            if (isDayMode) {
                ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                
                sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                sunLight.position.set(200, 300, 200);
                sunLight.castShadow = true;
                scene.add(sunLight);
                
                scene.background = new THREE.Color(0x87CEEB);
                
                // –í–∫–ª—é—á–∞–µ–º –≤—Å–µ –æ–≥–Ω–∏ –≤ –¥–Ω–µ–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ
                toggleLights(true);
            } else {
                ambientLight = new THREE.AmbientLight(0x444466, 0.3);
                scene.add(ambientLight);
                
                sunLight = new THREE.DirectionalLight(0x5566aa, 0.4);
                sunLight.position.set(-150, 200, -150);
                scene.add(sunLight);
                
                scene.background = new THREE.Color(0x1a237e);
                
                // –í–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º –æ–≥–Ω–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
                toggleLights(controls.lightsOn);
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è –æ—Å–≤–µ—â–µ–Ω–∏—è
        function toggleLights(on) {
            controls.lightsOn = on;
            
            // –£–ø—Ä–∞–≤–ª—è–µ–º —É–ª–∏—á–Ω—ã–º–∏ —Ñ–æ–Ω–∞—Ä—è–º–∏
            streetLights.forEach(light => {
                const lamp = light.children[1];
                if (lamp) {
                    lamp.material.color.set(on ? 0xffffaa : 0x333333);
                    lamp.material.emissive.set(on ? 0xffffaa : 0x000000);
                }
            });
            
            // –£–ø—Ä–∞–≤–ª—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ–º –≤ –æ–∫–Ω–∞—Ö (–∫—Ä–æ–º–µ —Å—Ç–∞–Ω—Ü–∏–∏)
            buildingLights.forEach(light => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Å–≤–µ—Ç –Ω–∞ —Å—Ç–∞–Ω—Ü–∏–∏
                if (Math.abs(light.position.x) > 200 || Math.abs(light.position.z) > 200) {
                    light.material.color.set(on ? 0xffffaa : 0x333333);
                    light.material.emissive.set(on ? 0xffffaa : 0x000000);
                }
            });
        }

        // –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π
        class CameraControls {
            constructor(camera) {
                this.camera = camera;
                this.target = new THREE.Vector3(0, 20, 0);
                this.distance = 150;
                this.phi = Math.PI / 3;
                this.theta = Math.PI / 4;
                
                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.isTouchDown = false;
                this.lastTouchX = 0;
                this.lastTouchY = 0;
                
                this.init();
            }
            
            init() {
                renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                renderer.domElement.addEventListener('wheel', this.onWheel.bind(this));
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Å–µ–Ω—Å–æ—Ä–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                renderer.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
                renderer.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));
                renderer.domElement.addEventListener('touchend', this.onTouchEnd.bind(this));
                
                this.updateCamera();
            }
            
            onMouseDown(event) {
                this.isMouseDown = true;
                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;
            }
            
            onMouseMove(event) {
                if (!this.isMouseDown) return;
                
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
                
                const deltaX = this.mouseX - this.lastMouseX;
                const deltaY = this.mouseY - this.lastMouseY;
                
                this.theta -= deltaX * 0.01;
                this.phi -= deltaY * 0.01;
                this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
                
                this.lastMouseX = this.mouseX;
                this.lastMouseY = this.mouseY;
                
                this.updateCamera();
            }
            
            onMouseUp() {
                this.isMouseDown = false;
            }
            
            onWheel(event) {
                this.distance += event.deltaY * 0.01;
                this.distance = Math.max(30, Math.min(300, this.distance));
                this.updateCamera();
            }
            
            onTouchStart(event) {
                if (event.touches.length === 1) {
                    this.isTouchDown = true;
                    this.lastTouchX = event.touches[0].clientX;
                    this.lastTouchY = event.touches[0].clientY;
                    event.preventDefault();
                }
            }
            
            onTouchMove(event) {
                if (!this.isTouchDown || event.touches.length !== 1) return;
                
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                
                const deltaX = touchX - this.lastTouchX;
                const deltaY = touchY - this.lastTouchY;
                
                this.theta -= deltaX * 0.01;
                this.phi -= deltaY * 0.01;
                this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
                
                this.lastTouchX = touchX;
                this.lastTouchY = touchY;
                
                this.updateCamera();
                event.preventDefault();
            }
            
            onTouchEnd() {
                this.isTouchDown = false;
            }
            
            updateCamera() {
                const x = this.distance * Math.sin(this.phi) * Math.cos(this.theta);
                const y = this.distance * Math.cos(this.phi);
                const z = this.distance * Math.sin(this.phi) * Math.sin(this.theta);
                
                this.camera.position.set(
                    this.target.x + x,
                    this.target.y + y,
                    this.target.z + z
                );
                this.camera.lookAt(this.target);
            }
            
            resetCamera() {
                if (currentLocation === 'station') {
                    this.target.set(0, 20, 0);
                    this.distance = 150;
                } else if (currentLocation === 'city') {
                    this.target.set(200, 30, -300);
                    this.distance = 250;
                } else if (currentLocation === 'settlement') {
                    this.target.set(600, 30, -300);
                    this.distance = 200;
                } else if (currentLocation === 'bridge') {
                    this.target.set(400, 15, -200);
                    this.distance = 100;
                }
                this.phi = Math.PI / 3;
                this.theta = Math.PI / 4;
                this.updateCamera();
            }
        }

        // –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∞–∫—Ç–æ—Ä–æ–º
        function updatePower(value) {
            reactorState.power = parseInt(value);
            document.getElementById('powerValue').textContent = reactorState.power;
            updateReactivity();
        }

        function updateRods(value) {
            reactorState.controlRods = parseInt(value);
            document.getElementById('rodsValue').textContent = reactorState.controlRods;
            updateReactivity();
        }

        function updateReactivity() {
            // –†–∞—Å—á–µ—Ç —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–æ—â–Ω–æ—Å—Ç–∏ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç–µ—Ä–∂–Ω–µ–π
            const powerFactor = reactorState.power / 1000;
            const rodsFactor = (211 - reactorState.controlRods) / 211;
            
            // –†–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ä–∞—Å—Ç–µ—Ç –ø—Ä–∏ –Ω–∏–∑–∫–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —Å—Ç–µ—Ä–∂–Ω–µ–π –∏ –≤—ã—Å–æ–∫–æ–π –º–æ—â–Ω–æ—Å—Ç–∏
            reactorState.reactivity = (powerFactor * rodsFactor * 4).toFixed(2);
            
            document.getElementById('reactivityValue').textContent = reactorState.reactivity;
            
            const warningElement = document.getElementById('reactivityWarning');
            
            if (reactorState.reactivity > 3.0) {
                warningElement.textContent = "–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –†–ï–ê–ö–¢–ò–í–ù–û–°–¢–¨! –û–ü–ê–°–ù–û–°–¢–¨ –í–ó–†–´–í–ê!";
                warningElement.className = "parameter-critical";
            } else if (reactorState.reactivity > 1.5) {
                warningElement.textContent = "–í–´–°–û–ö–ê–Ø –†–ï–ê–ö–¢–ò–í–ù–û–°–¢–¨! –ë—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã!";
                warningElement.className = "parameter-warning";
            } else {
                warningElement.textContent = "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å";
                warningElement.className = "parameter-warning";
            }
        }

        function activateAZ5() {
            if (reactorState.explosionTriggered) return;
            
            reactorState.az5Activated = true;
            document.getElementById('az5Warning').textContent = "–ê–ó-5 –ê–ö–¢–ò–í–ò–†–û–í–ê–ù–ê! –°—Ç–µ—Ä–∂–Ω–∏ –æ–ø—É—Å–∫–∞—é—Ç—Å—è...";
            document.getElementById('az5Warning').className = "parameter-critical";
            
            // –ï—Å–ª–∏ —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤—ã—à–µ 3.0, –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤–∑—Ä—ã–≤ (–∫–∞–∫ –≤ –ß–µ—Ä–Ω–æ–±—ã–ª–µ)
            if (reactorState.reactivity >= 3.0) {
                setTimeout(() => {
                    document.getElementById('az5Warning').textContent = "–í–ó–†–´–í –†–ï–ê–ö–¢–û–†–ê! –°—Ç–µ—Ä–∂–Ω–∏ –≤—ã–∑–≤–∞–ª–∏ —Å–∫–∞—á–æ–∫ –º–æ—â–Ω–æ—Å—Ç–∏!";
                    reactorState.explosionTriggered = true;
                    startExplosionSequence();
                }, 2000);
            } else {
                setTimeout(() => {
                    document.getElementById('az5Warning').textContent = "–†–µ–∞–∫—Ç–æ—Ä —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω";
                    document.getElementById('az5Warning').className = "parameter-warning";
                    
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∞–∫—Ç–æ—Ä–∞
                    reactorState.power = 0;
                    reactorState.controlRods = 211;
                    updatePower(0);
                    updateRods(211);
                }, 3000);
            }
        }

        // –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function startExplosionSequence() {
            if (!controls.explosionStarted) {
                controls.explosionStarted = true;
                updateStatus("üí• –í–ó–†–´–í –†–ï–ê–ö–¢–û–†–ê!", "catastrophe");
                
                // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –≤–∑—Ä—ã–≤–∞
                playExplosionSound();
                
                // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ —Å–∏—Ä–µ–Ω—ã
                playSirenSound();
                
                // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ —è–¥–µ—Ä–Ω–æ–π —Ç—Ä–µ–≤–æ–≥–∏
                playNuclearAlarm();
                
                // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –≤–∑—Ä—ã–≤–∞
                createExplosionEffects();
                
                // –í—ã–∫–ª—é—á–∞–µ–º —Å–≤–µ—Ç –≤–µ–∑–¥–µ
                toggleLights(false);
                stationLightsOn = false;
                updateStationLights();
                
                setTimeout(() => {
                    updateStatus("üö® –ê–í–ê–†–ò–ô–ù–ê–Ø –°–ò–¢–£–ê–¶–ò–Ø", "critical");
                }, 2000);
            }
        }

        function spawnEmergencyVehicles() {
            updateStatus("üöí –ê–í–ê–†–ò–ô–ù–ê–Ø –¢–ï–•–ù–ò–ö–ê –í–´–ï–•–ê–õ–ê", "warning");
            
            // –°–æ–∑–¥–∞–µ–º –∞–≤–∞—Ä–∏–π–Ω—É—é —Ç–µ—Ö–Ω–∏–∫—É
            for (let i = 0; i < 3; i++) {
                const fireTruck = createFireTruck();
                fireTruck.position.set(-200 + i * 20, 0.5, -100);
                fireTruck.userData = {
                    type: 'fire_truck',
                    speed: 0.1,
                    targetPosition: new THREE.Vector3(-50 + i * 20, 0.5, -50), // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è —Å–Ω–∞—Ä—É–∂–∏ —Å—Ç–∞–Ω—Ü–∏–∏
                    arrived: false
                };
                emergencyVehicles.push(fireTruck);
                scene.add(fireTruck);
            }
        }

        function startRebuildSequence() {
            controls.explosionStarted = false;
            controls.processesStopped = false;
            unit4Destroyed = false;
            stationLightsOn = true;
            evacuationStarted = false;
            reactorState.explosionTriggered = false;
            reactorState.az5Activated = false;
            
            updateStatus("üèóÔ∏è –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï –ù–ê–ß–ê–¢–û", "normal");
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∞–∫—Ç–æ—Ä–∞
            reactorState.power = 700;
            reactorState.controlRods = 187;
            reactorState.reactivity = 0.5;
            
            document.getElementById('powerValue').textContent = reactorState.power;
            document.getElementById('rodsValue').textContent = reactorState.controlRods;
            document.getElementById('reactivityValue').textContent = reactorState.reactivity;
            document.getElementById('powerSlider').value = reactorState.power;
            document.getElementById('rodsSlider').value = reactorState.controlRods;
            document.getElementById('reactivityWarning').textContent = "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å";
            document.getElementById('reactivityWarning').className = "parameter-warning";
            document.getElementById('az5Warning').textContent = "–ù–∞–∂–º–∏—Ç–µ –¥–ª—è —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ä–µ–∞–∫—Ç–æ—Ä–∞";
            document.getElementById('az5Warning').className = "parameter-warning";
            
            // –£–±–∏—Ä–∞–µ–º –∞–≤–∞—Ä–∏–π–Ω—É—é —Ç–µ—Ö–Ω–∏–∫—É
            emergencyVehicles.forEach(vehicle => {
                scene.remove(vehicle);
            });
            emergencyVehicles = [];
            
            // –£–±–∏—Ä–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –≤–∑—Ä—ã–≤–∞
            explosionEffects.forEach(effect => {
                scene.remove(effect);
            });
            explosionEffects = [];
            
            fireEffects.forEach(fire => {
                scene.remove(fire);
            });
            fireEffects = [];
            
            debrisParticles.forEach(debris => {
                scene.remove(debris);
            });
            debrisParticles = [];
            
            // –£–±–∏—Ä–∞–µ–º —á–µ—Ä–Ω—ã–π –¥—ã–º
            blackSmokeParticles.forEach(smoke => {
                scene.remove(smoke);
            });
            blackSmokeParticles = [];
            
            // –£–±–∏—Ä–∞–µ–º —Ä–∞–¥–∏–æ–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±–ª–∞–∫–æ
            if (radioactiveCloud) {
                scene.remove(radioactiveCloud);
                radioactiveCloud = null;
            }
            
            // –£–±–∏—Ä–∞–µ–º —Ä–∞–∑—Ä—É—à–µ–Ω–Ω—ã–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            if (destroyedUnit4) {
                scene.remove(destroyedUnit4);
                destroyedUnit4 = null;
            }
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º 4-–π —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫
            const unit4Group = createUnit4();
            unit4Group.position.set(0, 0, 0);
            scene.add(unit4Group);
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∞–∫—Ç–æ—Ä
            const reactorInterior = createReactorInterior(new THREE.MeshPhongMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.7,
                metalness: 0.4,
                roughness: 0.5
            }));
            reactorInterior.position.set(0, 5, 0);
            scene.add(reactorInterior);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã –æ–±—Ä–∞—Ç–Ω–æ
            machineHallEquipment.forEach(equipment => {
                equipment.userData.active = true;
            });
            
            // –í–∫–ª—é—á–∞–µ–º —Å–≤–µ—Ç –æ–±—Ä–∞—Ç–Ω–æ
            toggleLights(true);
            updateStationLights();
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ª—é–¥–µ–π –≤ –≥–æ—Ä–æ–¥
            if (cityPeople.length < 40) {
                for (let i = cityPeople.length; i < 40; i++) {
                    const person = createPerson();
                    person.position.set(
                        40 + Math.random() * 320,
                        0.5,
                        -320 + Math.random() * 40
                    );
                    person.userData = {
                        type: 'city_person',
                        direction: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01),
                        timer: 0,
                        evacuating: false
                    };
                    cityPeople.push(person);
                    scene.add(person);
                }
            }
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –≤ –≥–æ—Ä–æ–¥
            if (cityVehicles.length < 15) {
                for (let i = cityVehicles.length; i < 15; i++) {
                    const vehicle = createCar();
                    vehicle.position.set(
                        40 + Math.random() * 320,
                        0.5,
                        -300 + (Math.random() - 0.5) * 20
                    );
                    vehicle.userData = {
                        type: 'city_vehicle',
                        direction: new THREE.Vector3(0.02, 0, 0),
                        timer: 0
                    };
                    cityVehicles.push(vehicle);
                    scene.add(vehicle);
                }
            }
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ª—é–¥–µ–π –≤ –ø–æ—Å–µ–ª–µ–Ω–∏–µ
            if (settlementPeople.length < 15) {
                for (let i = settlementPeople.length; i < 15; i++) {
                    const person = createPerson();
                    person.position.set(
                        -50 + Math.random() * 100,
                        0.5,
                        -50 + Math.random() * 100
                    );
                    person.userData = {
                        type: 'person',
                        direction: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0, (Math.random() - 0.5) * 0.01),
                        timer: 0,
                        evacuating: false
                    };
                    settlementPeople.push(person);
                    scene.add(person);
                }
            }
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ª—é–¥–µ–π –Ω–∞ —Å—Ç–∞–Ω—Ü–∏—é
            if (stationPeople.length < 12) {
                for (let i = stationPeople.length; i < 12; i++) {
                    const person = createPerson();
                    person.position.set(
                        -100 + Math.random() * 200,
                        0.5,
                        -80 + Math.random() * 160
                    );
                    person.userData = {
                        type: 'station_person',
                        direction: new THREE.Vector3((Math.random() - 0.5) * 0.015, 0, (Math.random() - 0.5) * 0.015),
                        timer: 0,
                        evacuating: false
                    };
                    stationPeople.push(person);
                    scene.add(person);
                }
            }
            
            setTimeout(() => {
                updateStatus("‚úÖ –°–¢–ê–ù–¶–ò–Ø –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ê", "normal");
            }, 3000);
        }

        function toggleDayNight() {
            isDayMode = !isDayMode;
            setupLighting();
        }

        function switchToStation() {
            currentLocation = 'station';
            cameraControls.resetCamera();
            updateLocationButtons();
        }

        function switchToCity() {
            currentLocation = 'city';
            cameraControls.resetCamera();
            updateLocationButtons();
        }

        function switchToSettlement() {
            currentLocation = 'settlement';
            cameraControls.resetCamera();
            updateLocationButtons();
        }

        function switchToBridge() {
            currentLocation = 'bridge';
            cameraControls.resetCamera();
            updateLocationButtons();
        }

        function updateLocationButtons() {
            const buttons = document.querySelectorAll('.compact-controls button');
            buttons[0].classList.toggle('active', currentLocation === 'station');
            buttons[1].classList.toggle('active', currentLocation === 'city');
            buttons[2].classList.toggle('active', currentLocation === 'settlement');
            buttons[3].classList.toggle('active', currentLocation === 'bridge');
        }

        function updateStatus(text, level) {
            const indicator = document.getElementById('statusIndicator');
            const textElement = document.getElementById('statusText');
            
            textElement.textContent = text;
            indicator.className = 'status-indicator ' + level;
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        setupLighting();
        const cameraControls = new CameraControls(camera);

        const ground = createGround();
        scene.add(ground);

        const nuclearPlant = createExactChernobylPlant();
        scene.add(nuclearPlant);

        const city = createCity();
        scene.add(city);

        const settlement = createSettlement();
        scene.add(settlement);

        const bridge = createBridge();
        scene.add(bridge);

        // –î–æ–±–∞–≤–ª—è–µ–º –ª—é–¥–µ–π –Ω–∞ —Å—Ç–∞–Ω—Ü–∏—é
        const stationPeopleGroup = createStationPeople();
        scene.add(stationPeopleGroup);

        // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.explosionStarted) {
                controls.explosionTime += 0.016;
                document.getElementById('timeValue').textContent = controls.explosionTime.toFixed(1);
            }
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ª—é–¥–µ–π –∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
            animatePeopleAndVehicles();
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>